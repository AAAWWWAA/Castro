! This module stores the runtime parameters and integer names for 
! indexing arrays.
!
! The Fortran-specific parameters are initialized in set_method_params(),
! and the ones that we are mirroring from C++ and obtaining through the
! ParmParse module are initialized in set_castro_method_params().

module meth_params_module

  use bl_error_module

  implicit none

  ! number of ghost cells for the hyperbolic solver
  integer, parameter     :: NHYP    = 4

  ! NTHERM: number of thermodynamic variables
  integer, save :: NTHERM, NVAR
  integer, save :: URHO, UMX, UMY, UMZ, UMR, UML, UMP, UEDEN, UEINT, UTEMP, UFA, UFS, UFX
  integer, save :: USHK

  ! QTHERM: number of primitive variables
  integer, save :: QTHERM, QVAR
  integer, save :: QRHO, QU, QV, QW, QPRES, QREINT, QTEMP, QGAME
  integer, save :: NQAUX, QGAMC, QC, QCSML, QDPDR, QDPDE
#ifdef RADIATION
  integer, save :: QGAMCG, QCG
#endif
  integer, save :: QFA, QFS, QFX

  integer, save :: nadv

  ! NQ will be the total number of primitive variables, hydro + radiation
  integer, save :: NQ         

#ifdef RADIATION
  integer, save :: QRADVAR, QRAD, QRADHI, QPTOT, QREITOT
  integer, save :: fspace_type
  logical, save :: do_inelastic_scattering
  logical, save :: comoving

  double precision, save :: flatten_pp_threshold = -1.d0
#endif

  integer, save :: npassive
  integer, save, allocatable :: qpass_map(:), upass_map(:)

  ! These are used for the Godunov state
  ! Note that the velocity indices here are picked to be the same value
  ! as in the primitive variable array
  integer, save :: ngdnv, GDRHO, GDU, GDV, GDW, GDPRES, GDGAME, GDLAMS, GDERADS

  integer         , save :: numpts_1d

  double precision, save, allocatable :: outflow_data_old(:,:)
  double precision, save, allocatable :: outflow_data_new(:,:)
  double precision, save :: outflow_data_old_time
  double precision, save :: outflow_data_new_time
  logical         , save :: outflow_data_allocated
  double precision, save :: max_dist

  double precision, save :: diffuse_cutoff_density

  character(len=:), allocatable :: gravity_type

  ! Create versions of these variables on the GPU
  ! the device update is then done in Castro_nd.f90

  !$acc declare &
  !$acc create(NTHERM, NVAR) &
  !$acc create(URHO, UMX, UMY, UMZ, UMR, UML, UMP, UEDEN, UEINT, UTEMP, UFA, UFS,UFX) &
  !$acc create(USHK) &
  !$acc create(QTHERM, QVAR) &
  !$acc create(QRHO, QU, QV, QW, QPRES, QREINT, QTEMP) &
  !$acc create(QGAMC, QGAME) &
  !$acc create(NQ) &
#ifdef RADIATION
  !$acc create(QGAMCG, QCG) &
  !$acc create(QRADVAR, QRAD, QRADHI, QPTOT, QREITOT) &
  !$acc create(fspace_type, do_inelastic_scattering, comoving)
#endif
  !$acc create(QFA, QFS, QFX)

  ! Begin the declarations of the ParmParse parameters

  @@f90_declarations@@

  ! End the declarations of the ParmParse parameters

  double precision, save :: rot_vec(3)

contains

  subroutine set_castro_method_params() bind(C,name="set_castro_method_params")

    use parmparse_module, only: parmparse_build, parmparse_destroy, ParmParse

    implicit none

    type (ParmParse) :: pp

    call parmparse_build(pp, "castro")

    @@set_castro_params@@

    call parmparse_destroy(pp)

  end subroutine set_castro_method_params

#ifdef RADIATION
  subroutine get_qradvar(qradvar_in) bind(C, name="get_qradvar")

    implicit none

    integer, intent(inout) :: qradvar_in

    qradvar_in = QRADVAR

  end subroutine get_qradvar

  subroutine ca_init_radhydro_pars(fsp_type_in, do_is_in, com_in,fppt) &
       bind(C, name="ca_init_radhydro_pars")

    use rad_params_module, only : ngroups

    integer, intent(in) :: fsp_type_in, do_is_in, com_in
    double precision, intent(in) :: fppt

    QPTOT  = QVAR+1
    QREITOT = QVAR+2
    QRAD = QVAR+3
    QRADHI = qrad+ngroups-1
  
    QRADVAR = QVAR + 2 + ngroups
  
    ! update NQ -- it was already initialized in the hydro
    NQ = QRADVAR

    if (ngroups .eq. 1) then
       fspace_type = 1
    else
       fspace_type = fsp_type_in
    end if
    
    if (fsp_type_in .ne. 1 .and. fsp_type_in .ne. 2) then
       call bl_error("Unknown fspace_type", fspace_type)
    end if
    
    do_inelastic_scattering = (do_is_in .ne. 0)
    
    if (com_in .eq. 1) then
       comoving = .true.
    else if (com_in .eq. 0) then
       comoving = .false.
    else
       call bl_error("Wrong value for comoving", fspace_type)
    end if
    
    flatten_pp_threshold = fppt
    
    !$acc update &
    !$acc device(NQ) &
    !$acc device(QRADVAR, QRAD, QRADHI, QPTOT, QREITOT) &
    !$acc device(fspace_type) &
    !$acc device(do_inelastic_scattering) &
    !$acc device(comoving)
    !$acc device(flatten_pp_threshold = -1.d0)

  end subroutine ca_init_radhydro_pars
#endif

end module meth_params_module
