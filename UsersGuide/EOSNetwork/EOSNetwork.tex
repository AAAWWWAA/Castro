\section{Equation of State}
CASTRO is written in a modular fashion so that the EOS and network
burning routines can be supplied by the user.   However, for the
examples presented later we use several EOS and network routines
that come with the CASTRO distribution.  

EOS routines that come with CASTRO are (listed by directory name):
\begin{itemize}
\item {\bf Gamma\_Law\_General} directory represents a gamma law gas, with equation of state:
\begin{equation}
  P = (\gamma - 1) \rho e.
\end{equation}
The gas is currently assumed to be monatomic and ideal. The entropy comes from the Sackur-Tetrode equation.
\item {\bf Polytrope} directory represents a polytropic fluid, with equation of state:
\begin{equation}
  P = K \rho^\gamma.
\end{equation}
The gas is also assumed to obey the above gamma law equation of state connecting the pressure and internal energy. Therefore $\rho$ is the only independent variable; there is no temperature dependence. The user either selects from a set of predefined options reflecting physical polytropes (e.g. a non-relativistic, fully degenerate electron gas) or inputs their own values for $K$ and $\gamma$.
\item {\bf HelmEOS} directory contains a general, publicly available
stellar equation of state based on the Helmholtz free energy,
with contributions from ions, radiation, and electron degeneracy, as
described in (Timmes and Arnett 1999, Times and Swesty 2000, and Fryxell et al. 2000).
\item {\bf LattimerSwestyEOS} directory contains a modified version of the
LS EOS available at http://www.astro.sunysb.edu/dswesty.  Full
documentation is available through that web site.  We use this EOS
in the 1D core collapse supernova example in a later section.
\end{itemize}

Each EOS should have two main routines by which it interfaces to the rest of CASTRO.
At the beginning of the simulation, {\bf \rm eos\_init} will perform any initialization steps and save EOS variables (mainly \texttt{smallt}, the temperature floor, and \texttt{smalld}, the density floor). Then, whenever you want to call the EOS, use
\[
{\bf \rm eos}(\texttt{eos\_input, eos\_state, do\_eos\_diag, pt\_index}).
\]
The first argument specifies the inputs to the EOS, which will be held constant. The options that are currently available are stored in \texttt{EOS/eos\_data.F90}, and are always a combination of two thermodynamic quantities. For real (non-analytic) equations of state in which $\rho$, $T$ and species are the independent variables, such as the Helmholtz EOS, \texttt{eos\_input\_rt} directly calls the EOS and obtains the other thermodynamic variables (internal energy, pressure, $\gamma$, sound speed, etc.). For other inputs, e.g. \texttt{eos\_input\_re}, a Newton-Raphson iteration is performed to find the density or temperature that corresponds to the given input.

The \texttt{eos\_state} variable is a Fortran derived type (similar to a C++ struct). It stores a complete set of thermodynamic variables. When calling the EOS, you should first fill the variables that are the inputs, for example with
\begin{align*}
  &\texttt{eos\_state } \% \texttt{ rho = state(i,j,k,URHO)} \\
  &\texttt{eos\_state } \% \texttt{ e   = state(i,j,k,UEINT) / state(i,j,k,URHO)} \\
  &\texttt{eos\_state } \% \texttt{ xn  = state(i,j,k,UFS:UFS+nspec-1) / state(i,j,k,URHO)}.
\end{align*}
Whenever the \texttt{eos\_state} type is initialized, the thermodynamic state variables are filled with unphysical numbers. If you do not input the correct arguments to match your input quantities, the EOS will call an error. However, this means that it is good practice to fill the quantities that will be iterated over with an initial guess. The values they are initialized with will likely not converge. Usually a prior value of the temperature or density suffices if it's available, but if not then use \texttt{small\_temp} or \texttt{small\_dens}.

The last two arguments are optional quantities: set \texttt{do\_eos\_diag} to \texttt{.true.} if you want diagnostic output as the iterations occur, and set \texttt{pt\_index} to be equal to the indices of the current zone if you want the zone information to be displayed on any error messages.

Finally, please note that there is an important difference with how the Helmholtz EOS is treated now, compared to CASTRO's original behavior, when the temperature or density reaches their respective floors (\texttt{small\_temp} and \texttt{small\_dens}) in a Newton-Raphson iteration (such as when you call it with \texttt{eos\_input\_re}). Previously, we would have the outgoing state be thermodynamically inconsistent because the density or temperature would be floored but the internal energy would be the same as the input. Now, by default, the outgoing state is always thermodynamically consistent, which means that the argument that was previously held constant may substantially differ from its input. In our testing, we have found that retaining this thermodynamic consistency is necessary for accurately treating shocks. If you wish to disable this behavior, set \texttt{eos\_input\_is\_constant = F} in your \texttt{extern} namelist in your probin file.

\section{Burning Network}
Burning network routines that come with CASTRO are (listed by directory name):
\begin{itemize}
\item {\bf networks/null} directory describes a non-reacting white dwarf,
with only hydrogen, helium and carbon12.   There are
no auxiliary variables, and no reactions are allowed.
\item {\bf networks/collapse} directory describes a pre-supernova neutron
star with hydrogen, helium, oxygen and iron, There is one auxiliary
variable, Ye, the electron fraction.  Again no reactions are
allowed.
\item {\bf networks/ignition} directory contains a single-step
$^{12}\mathrm{C}(^{12}\mathrm{C},\gamma)^{24}\mathrm{Mg}$ reaction.
The carbon mass fraction equation appears as
\begin{equation}
\frac{D X(^{12}\mathrm{C})}{Dt} = - \frac{1}{12} \rho X(^{12}\mathrm{C})^2
    f_\mathrm{Coul} \left [N_A \left <\sigma v \right > \right]\enskip,
\end{equation}
where $N_A \left <\sigma v\right>$ is evaluated using the reaction
rate from (Caughlan and Fowler 1988).  The Coulomb screening factor,
$f_\mathrm{Coul}$, is evaluated using the general routine from the
Kepler stellar evolution code (Weaver 1978), which implements
the work of (Graboske 1973) for weak screening and the work of
(Alastuey 1978 and Itoh 1979) for strong screening.
\end{itemize}

There are two primary files within each network directory. The first,
castro\_burner.f90, contains the burner routine, 
which takes $\rho^\inp, e^\inp, X_k^\inp$, and $\Delta t$ as inputs.
It is possible for the internal energy, $e$, which is computed from $\Ub$, to be
negative due to roundoff error.  CASTRO has an option to protect against using a 
negative value of $e$ by recomputing $e = e(\rho,T_{\rm small},X_k)$ using the 
equation of state, where $T_{\rm small}$ is a user-defined temperature floor.  In the 
event that $e$ is still negative, we abort the program.  CASTRO also has an option to
skip the reactions if the density is below a user-defined density floor.

Next, the burner computes $T = T(\rho^\inp,e^\inp,X_k^\inp)$ using the equation of state.
The burner returns $X_k^\outp$ and $e^\outp$ by solving over a time interval of $\Delta t/2$,
\begin{eqnarray}
\frac{\partial X_k}{\partial t} &=& \omegadot_k.\\
\end{eqnarray}
In particular, to evolve the species, we solve the system:
\begin{eqnarray}
\frac{dX_k}{dt} &=& \omegadot_k(\rho,X_k,T)\enskip, \label{eq:VODE1C} \\
\frac{dT}{dt} &=&\frac{1}{c_p} \left ( -\sum_k \xi_k  \omegadot_k  \right )\enskip. \label{eq:tempreactC}
\end{eqnarray}
\MarginPar{Need to include temperature evolution equation somewhere}
using the stiff ordinary differential equation integration methods provided by 
the VODE package.  The absolute error tolerances are set to 
$10^{-12}$ for the species, and a relative tolerance of $10^{-5}$ is used for 
the temperature.  The integration yields the new values of the mass fractions, 
$X_k^\outp$.  Equation (\ref{eq:tempreactC}) is derived from equation (???) by 
assuming that the pressure is constant during the burn state.  In evolving these 
equations, we need to evaluate $c_p$ and $\xi_k$.  In theory, this means 
evaluating the equation of state for each right-hand side evaluation that 
VODE requires.  In practice, we freeze $c_p$ and $\xi_k$ at the start of 
the integration time step and compute them using $\rho^\inp, X_k^\inp,$ and $T^\inp$ 
as inputs to the equation of state.  Note that the density remains unchanged during 
the burning.  At the end of the routine, we compute 
$T^\outp = T(\rho^\outp,e^{\outp},X_k^\outp)$.

The second file, ``network.f90'', supply the
number of species and auxiliary variables, names of each species and 
auxiliary variable, as well as other initializing data, such as
aion, zion and the binding energy.

It is straightforward to implement additional EOS and network routines; all that is required
is to create an appropriate interface to the CASTRO calls, which is easily done given
the prototypes supplied with the CASTRO distribution.
