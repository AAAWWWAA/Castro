\section{Primary Data-structures}

\castro\ is built on the \cpp\ \boxlib\ framework, and relies on the
{\tt Amr} class defined there to drive the simulation.

The following other classes / concepts also play a major role laying
out \castro's algorithm:
\begin{itemize}
\item \code{AmrLevel} : this is a class that has the whole fluid state \MarginPar{more}

\item \code{Castro} : this is an {\tt AmrLevel}-derived class for a
  single level---it contains all the data needed to advance the state
  for a single level

\item \code{MultiFab} : this is the collection of boxes (w/ data) at the 
  same level of refinement.  A \tt {\tt MultiFab} can have multiple
  components, ghost cells, etc.  \MarginPar{what else? does it know about boundaries?}

\item \code{\statedata}

\end{itemize}


\section{Overview of a single step (no SDC)}

The main evolution for a single step is contained in
\code{Castro\_advance.cpp}, as \code{Castro::advance()}.  This does
the following advancement.  Note, some parts of this are only done
depending on which preprocessor directives are defined at
compile-time---the relevant directive is noted in the [\ ] at the start
of each step.

\begin{enumerate}
\item {\em Initialization} 

  This sets up the current level for advancement.  If we are at the
  start of a coarse level timestep, or we are in the middle of
  subcycling on a finer level (\code{amr\_iteration} {\tt > 1}), then
  we swap the \statedata\ from the new to old (e.g., this ensures that
  the next evolution starts with the result from the previous step).

  This also syncs up the level information to the Fortran-side of
  \castro, does any radiation initialization, and initializes all of
  the intermediate storage arrays (like those that hold source terms,
  etc.).

\item {\em Advancement} 

  This is calls \code{do\_advance} to take a single step,
  incorporating hydrodynamics, reactions, and source terms.  For
  radiation-hydrodynamics, this step does the advective (hyperbolic)
  portion of the radiation update only.

  \MarginPar{Diffusion?}

  \MarginPar{where is gravity hooked in?}


  If \runparam{castro.use\_retry} is set, then we subcycle the current
  step if we violated any stability criteria to reach the desired
  $\Delta t$. \MarginPar{more?}

If the timestep that you took had a timestep that was not sufficient to
enforce the stability criteria that you would like to achieve, such as
the CFL criterion for hydrodynamics or the burning stability criterion
for reactions, you can retry the timestep by setting {\tt castro.use\_retry = 1}
in your inputs file. This will save the current state data at the beginning
of the level advance, and then if the criteria are not satisfied, will
reject that advance and start over from the old data, with a series of
subcycled timesteps that should be small enough to satisfy the criteria.
Note that this will effectively double the memory footprint on each level
if you choose to use it.


\item {[\ifdef{AUX\_UPDATE}]} {\em Auxillary quantitiy evolution} 

  Auxillary variables in Castro are those that obey a continuity
  equation (with optional sources) that are passed into the EOS, but
  not subjected to the constraint on mass fractions (summing to one).

  The advection and source terms are already dealt with in the 
  main hydrodynamics advance (above step).  A user-supplied routine
  \code{ca\_auxupdate} can be provided here to further update these
  quantities.
  
\item {[\ifdef{LEVELSET}]} {\em Levelsets} 

  Basic support for level sets was added to \castro, but is not currently
  supported.  This is the hook for where the advancement would be done.

\item {\em Radial data and {\rm[\ifdef{POINTMASS}]} point mass} 

  If \runparam{castro.spherical\_star} is set, then we average the state data
  over angles here to create a radial profile.  This is then used in the 
  boundary filling routines to properly set Dirichlet BCs when our domain
  is smaller than the star, so the profile on the boundaries will not 
  be uniform.

  If \runparam{castro.point\_mass\_fix\_solution} is set, then we
  change the mass of the point mass that optionally contributes to the
  gravitational potential by taking mass from the surrounding zones
  (keeping the density in those zones constant).

\item {[\ifdef{RADIATION}]} {\em Radiation implicit update} 

  The {\tt do\_advance()} routine only handled the hyperbolic
  portion of the radiation update.  This step does the implicit solve
  (either gray or multigroup) to advance the radiation energies to the 
  new time level.  Note that at the moment, this is backward-difference
  implicit (first-order in time) for stability.

  This is handled by \code{final\_radiation\_call()}.

\item {[\ifdef{PARTICLES}]} {\em Particles} 

  If we are including passively-advected particles, they are
  advanced in this step.

\item {\em Finalize}

  This cleans up the memory used during the step.  

  If \runparam{castro.track\_grid\_losses} is set, then we also add up
  the mass that left through the boundary over this step. \MarginPar{do this use masks to ensure no double counting if multiple levels touch the boundary?}

\end{enumerate}

\subsection{Main Hydro, Reaction, and Gravity Advancement (Strang-splitting)}

The explicit portion of the system advancement (reactions,
hydrodynamics, and gravity) is done by \code{do\_advance()}.  
Consider our system of equations as:
\begin{equation}
\frac{\partial\Ub}{\partial t} = \nabla\cdot\Fb + \Sb_{\rm react} + \Sb,
\end{equation}
where $\Fb$ is the flux vector, $\Sb_{\rm react}$ are the reaction
source terms, and $\Sb$ are the non-reaction source terms, which
includes any user-defined external sources, $\Sb_{\rm ext}$.  We use
Strang splitting to discretize the advection-reaction equations.  In
summary, for each time step, we update the conservative variables,
$\Ub$, by reacting for half a time step, advecting for a full time
step (ignoring the reaction terms), and reacting for half a time step:
\begin{equation}
\Ub^n = \Ub^n + \frac{\dt}{2}\Sb_{\rm react}^n,
\end{equation}
\begin{equation}
\Ub^{n+1} = \Ub^n - \Delta t \nabla \cdot\Fb^\nph + \dt\frac{\Sb^n + \Sb^{n+1}}{2},
\end{equation}
\begin{equation}
\Ub^{n+1} = \Ub^{n+1} + \frac{\dt}{2}\Sb_{\rm react}^{n+1},
\end{equation}
The construction of $F$ is purely explicit, and based on an unsplit
second-order Godunov method.  We predict the standard primitive
variables, as well as $\rho e$, at time-centered edges and use an
approximate Riemann solver construct fluxes.  At the beginning of the
time step, we assume that $\Ub$ and $\phi$ are defined consistently,
i.e., $\rho^n$ and $\phi^n$ satisfy equation (\ref{eq:Self
  Gravity}).

\castro\ also supports radiation.  This part of the update algorithm
only deals with the advective / hyperbolic terms in the radiation update.

Here is the single-level algorithm.  In the code, the objective is to
evolve the state from the old time, {\tt S\_old}, to the new time,
{\tt S\_new}.  \MarginPar{Sborder?}

\begin{enumerate}
\item {\em Initialize}

This resets the flux registers and initializes a lot of intermediate
storage arrays (like source term) to zero.

We also check for NaNs in the initial state, {\tt S\_old}.

\item {\em React $\Delta t/2$.}

Update the solution due to the effect of reactions over half a time
step.  The integration method and system of equations used here is
determined by a host of runtime parameters that are part of the
\microphysics\ package.  But the basic idea is to evolve the energy
release from the reactions, the species mass fractions, and temperature
through $\Delta t/2$.

\begin{eqnarray}
(\rho E)^n &=& (\rho E)^n - \frac{\dt}{2}\sum_k(\rho q_k\omegadot_k)^n,\\
(\rho X_k)^n &=& (\rho X_k)^n + \frac{\dt}{2}(\rho\omegadot_k)^n.
\end{eqnarray} \MarginPar{up this}

At the end of the reactions, we copy the updated data into {\tt S\_new} \MarginPar{why?}


\item {\em Construct time-level $n$ sources and apply}

The time level $n$ sources are applied to the new state, {\tt S\_new},
with a full $\Delta t$ weighting (this will be corrected later)

The sources that we deal with here are:
\begin{enumerate}
  \item sponge

  \item external sources

  \item {[\ifdef{DIFFUSION}]} diffusion

  \item {[\ifdef{HYBRID\_MOMENTUM}]} angular momentum 

  \item {[\ifdef{GRAVITY}]} gravity:

    For full Poisson gravity, we solve for for gravity using:
    \begin{equation}
      \gb^n = -\nabla\phi^n, \qquad
      \Delta\phi^n = 4\pi G\rho^n,
    \end{equation}

    The construction of the form of the gravity source for the
    momentum and energy equation is dependent on the parameter
    \runparam{castro.grav\_source\_type}.  Full details of the gravity
    solver are given in Chapter~\ref{ch:gravity}.

    \MarginPar{we should add a description of whether we do a level solve or a composite solve}

    \MarginPar{what do we store? phi and g? source?}

  \item {[\ifdef{ROTATION}]} rotation

    We compute the rotational potential (for use in the energy update) 
    and the rotational acceleration (for use in the momentum equation).
    The form of the rotational source that is constructed then depends
    on the parameter \runparam{castro.rot\_source\_type}
    
\end{enumerate}


\item {\em Construct the hydro update}

The goal is to advance
\begin{equation}
\Ub^{n+1,\star} = \Ub^n - \dt\nabla\cdot\Fb^\nph + \dt\Sb^n.
\end{equation}
neglecting reaction terms.  Note that since the source term is not
time centered (this is what we did in the previous step), this is not
a second-order method.  After the advective update, we correct the
solution, effectively time-centering the source term.

We do the hydro update in two parts---first we construct the advective
update and store it, then we do the conservative update in a separate
step.  This separation allows us to use the advective update
separately in more complex time-integration schemes.

The advection step is complicated, and more detail is given in
Section \ref{Sec:Advection Step}.  Here is the summarized version:
\begin{enumerate}
\item Compute primitive variables.
\item Predict primitive variables to time-centered edges.
\item Solve the Riemann problem.
\item Compute fluxes and update.
\end{enumerate}


To start the hydrodynamics, we need to know the hydrodynamics source
terms at time-level $n$.  This is essentially the same vector that was
computed in the previous step, with a few modifications.  The most
important is that if we set \runparam{castro.source\_term\_predictor},
then we extrapolate the source terms from $n$ to $n+1/2$, using the
change from the previous step. \MarginPar{does this work?}

Note: we neglect the reaction source terms, since those are already
accounted for in the state directly, due to the Strang-splitting 
nature of this method.


\item {\em Update radial data and center of mass for monopole gravity}
 \MarginPar{is that right?}


\item {\em Clean State}

Need to describe this

Also check for NaNs.


\item {\em Correct the source terms with the $n+1$ contribution}

Previously we added $\Delta t S^n$ to the state, when we really want
a time-centered approach, $(\Delta t/2)(S^n + S^{n+1})$.  We fix 
that here.

We start by compute the source term vector $S^{n+1}$ using the 
updated data, $U^{n+1,\star}$.  We then compute the correction,
$(\Delta t/2)(S^{n+1} - S^n)$ to add to $U^{n+1,\star}$ to
give us the properly time-centered source, $U^{n+1}$.

We have a choice of how to do this correction.  We can first compute
all the corrections using the same initial state, $U^{n+1,\star}$, and
then apply them all.  Or we can compute them one-by-one applying them
as we go.  This behavior is controlled by the parameter
\runparam{castro.update\_state\_between\_sources}.

In the process of updating the sources, we update the temperature
to make it consistent with the new state.

%% We need to correct the solution by effectively time-centering the
%% source terms.  These corrections are to be performed sequentially
%% since new source term evaluations may depend on previous corrections.

%% First, we correct the solution with the updated gravity:
%% \begin{eqnarray}
%% (\rho\ub)^{n+1} &=& (\rho\ub)^{n+1} + \frac{\dt}{2}\left[(\rho\gb)^{n+1} - (\rho\gb)^n\right], \\
%% (\rho E)^{n+1} &=& (\rho E)^{n+1} + \frac{\dt}{2}\left[\left(\rho\ub\cdot\gb\right)^{n+1} - \left(\rho\ub\cdot\gb\right)^n\right].
%% \end{eqnarray}

%% Next, we correct $\Ub$ with updated external sources.  For example,
%% for the momentum, we correct using
%% \begin{equation}
%% (\rho\ub)^{n+1} = (\rho\ub)^{n+1} + \frac{\dt}{2}\left(\Sb_{{\rm ext},\rho\ub}^{n+1} - \Sb_{{\rm ext},\rho\ub}^n\right).
%% \end{equation}
%% We correct $\rho E, \rho A_k, \rho X_k$, and $\rho Y_k$ in an
%% analogous manner.

%% Finally, we correct the solution with updated thermal diffusion using
%% \begin{equation}
%% (\rho E)^{n+1} = (\rho E)^{n+1} + \frac{\dt}{2}\left(\nabla\cdot\kappa\nabla T^{n+1} - \nabla\cdot\kappa\nabla T^n\right).
%% \end{equation}


\item {\em React $\Delta t/2$.}

Update the solution due to the effect of reactions over half a time step.
\begin{eqnarray}
(\rho E)^{n+1} &=& (\rho E)^{n+1} - \frac{\dt}{2}\sum_k(\rho q_k\omegadot_k)^{n+1},\\
(\rho X_k)^{n+1} &=& (\rho X_k)^{n+1} + \frac{\dt}{2}(\rho\omegadot_k)^{n+1}.
\end{eqnarray}


\item {\em Finalize}

TBD



\end{enumerate}

