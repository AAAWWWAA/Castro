\section{Primary Data-structures}

\castro\ is built on the \cpp\ \boxlib\ framework, and relies on the
{\tt Amr} class defined there to drive the simulation.

The following other classes / concepts also play a major role laying
out \castro's algorithm:
\begin{itemize}
\item \code{AmrLevel} : this is a class that has the whole fluid state \MarginPar{more}

\item \code{Castro} : this is an {\tt AmrLevel}-derived class for a
  single level---it contains all the data needed to advance the state
  for a single level

\item \code{MultiFab} : this is the collection of boxes (w/ data) at the 
  same level of refinement.  A \tt {\tt MultiFab} can have multiple
  components, ghost cells, etc.  \MarginPar{what else? does it know about boundaries?}

\item \code{\statedata}

\end{itemize}


\section{Overview of a single step (no SDC)}

The main evolution for a single step is contained in
\code{Castro\_advance.cpp}, as \code{Castro::advance()}.  This does
the following advancement.  Note, some parts of this are only done
depending on which preprocessor directives are defined at
compile-time---the relevant directive is noted in the [\ ] at the start
of each step.

\begin{enumerate}
\item {\em Initialization} 

  This sets up the current level for advancement.  If we are at the
  start of a coarse level timestep, or we are in the middle of
  subcycling on a finer level (\code{amr\_iteration} {\tt > 1}), then
  we swap the \statedata\ from the new to old (e.g., this ensures that
  the next evolution starts with the result from the previous step).

  This also syncs up the level information to the Fortran-side of
  \castro, does any radiation initialization, and initializes all of
  the intermediate storage arrays (like those that hold source terms,
  etc.).

\item {\em Advancement} 

  This is calls \code{do\_advance} to take a single step,
  incorporating hydrodynamics, reactions, and source terms.  For
  radiation-hydrodynamics, this step does the advective (hyperbolic)
  portion of the radiation update only.

  \MarginPar{Diffusion?}

  \MarginPar{where is gravity hooked in?}


  If \runparam{castro.use\_retry} is set, then we subcycle the current
  step if we violated any stability criteria to reach the desired
  $\Delta t$. \MarginPar{more?}

\item {[\ifdef{AUX\_UPDATE}]} {\em Auxillary quantitiy evolution} 

  Auxillary variables in Castro are those that obey a continuity
  equation (with optional sources) that are passed into the EOS, but
  not subjected to the constraint on mass fractions (summing to one).

  The advection and source terms are already dealt with in the 
  main hydrodynamics advance (above step).  A user-supplied routine
  \code{ca\_auxupdate} can be provided here to further update these
  quantities.
  
\item {[\ifdef{LEVELSET}]} {\em Levelsets} 

  Basic support for level sets was added to \castro, but is not currently
  supported.  This is the hook for where the advancement would be done.

\item {\em Radial data and {\rm[\ifdef{POINTMASS}]} point mass} 

  If \runparam{castro.spherical\_star} is set, then we average the state data
  over angles here to create a radial profile.  This is then used in the 
  boundary filling routines to properly set Dirichlet BCs when our domain
  is smaller than the star, so the profile on the boundaries will not 
  be uniform.

  If \runparam{castro.point\_mass\_fix\_solution} is set, then we
  change the mass of the point mass that optionally contributes to the
  gravitational potential by taking mass from the surrounding zones
  (keeping the density in those zones constant).

\item {[\ifdef{RADIATION}]} {\em Radiation implicit update} 

  The {\tt do\_advance()} routine only handled the hyperbolic
  portion of the radiation update.  This step does the implicit solve
  (either gray or multigroup) to advance the radiation energies to the 
  new time level.  Note that at the moment, this is backward-difference
  implicit (first-order in time) for stability.

  This is handled by \code{final\_radiation\_call()}.

\item {[\ifdef{PARTICLES}]} {\em Particles} 

  If we are including passively-advected particles, they are
  advanced in this step.

\item {\em Finalize}

  This cleans up the memory used during the step.  

  If \runparam{castro.track\_grid\_losses} is set, then we also add up
  the mass that left through the boundary over this step. \MarginPar{do this use masks to ensure no double counting if multiple levels touch the boundary?}

\end{enumerate}

\subsection{Main Hydro, Reaction, and Gravity Advancement (Strang-splitting)}

The explicit portion of the system advancement (reactions,
hydrodynamics, and gravity) is done by \code{do\_advance()}.  
Consider our system of equations as:
\begin{equation}
\frac{\partial\Ub}{\partial t} = \nabla\cdot\Fb + \Sb_{\rm react} + \Sb,
\end{equation}
where $\Fb$ is the flux vector, $\Sb_{\rm react}$ are the reaction
source terms, and $\Sb$ are the non-reaction source terms, which
includes any user-defined external sources, $\Sb_{\rm ext}$.  We use
Strang splitting to discretize the advection-reaction equations.  In
summary, for each time step, we update the conservative variables,
$\Ub$, by reacting for half a time step, advecting for a full time
step (ignoring the reaction terms), and reacting for half a time step:
\begin{equation}
\Ub^n = \Ub^n + \frac{\dt}{2}\Sb_{\rm react}^n,
\end{equation}
\begin{equation}
\Ub^{n+1} = \Ub^n - \Delta t \nabla \cdot\Fb^\nph + \dt\frac{\Sb^n + \Sb^{n+1}}{2},
\end{equation}
\begin{equation}
\Ub^{n+1} = \Ub^{n+1} + \frac{\dt}{2}\Sb_{\rm react}^{n+1},
\end{equation}
The construction of $F$ is purely explicit, and based on an unsplit
second-order Godunov method.  We predict the standard primitive
variables, as well as $\rho e$, at time-centered edges and use an
approximate Riemann solver construct fluxes.  At the beginning of the
time step, we assume that $\Ub$ and $\phi$ are defined consistently,
i.e., $\rho^n$ and $\phi^n$ satisfy equation (\ref{eq:Self
  Gravity}).

\castro\ also supports radiation.  This part of the update algorithm
only deals with the advective / hyperbolic terms in the radiation update.

Here is the single-level algorithm.  In the code, the objective is to
evolve the state from the old time, {\tt S\_old}, to the new time,
{\tt S\_new}.  \MarginPar{Sborder?}

\begin{enumerate}
\item {\em Initialize}

This resets the flux registers and initializes a lot of intermediate
storage arrays (like source term) to zero.

We also check for NaNs in the initial state, {\tt S\_old}.

\item {\em React $\Delta t/2$.}

Update the solution due to the effect of reactions over half a time
step.  The integration method and system of equations used here is
determined by a host of runtime parameters that are part of the
\microphysics\ package.  But the basic idea is to evolve the energy
release from the reactions, the species mass fractions, and temperature
through $\Delta t/2$.

\begin{eqnarray}
(\rho E)^n &=& (\rho E)^n - \frac{\dt}{2}\sum_k(\rho q_k\omegadot_k)^n,\\
(\rho X_k)^n &=& (\rho X_k)^n + \frac{\dt}{2}(\rho\omegadot_k)^n.
\end{eqnarray} \MarginPar{up this}

At the end of the reactions, we copy the updated data into {\tt S\_new} \MarginPar{why?}


\item {\em Construct time-level $n$ sources and apply}

This includes the gravity source.  For full Poisson gravity, we solve
for for gravity using:
\begin{equation}
\gb^n = \nabla\phi^n, \qquad 
\Delta\phi^n = 4\pi G\rho^n,
\end{equation}

The time level $n$ sources are applied to the new state, {\tt S\_new},
with a full $\Delta t$ weighting (this will be corrected later)





\item[Step 3:] {\em Compute explicit source terms.}

We now compute explicit source terms for each variable in $\Qb$ and
$\Ub$.  The primitive variable source terms will be used to construct
time-centered fluxes.  The conserved variable source will be used to
advance the solution.  We neglect reaction source terms since they are
accounted for in {\bf Steps 1} and {\bf 6}.  The source terms are:
\begin{equation}
\Sb_{\Qb}^n =
\left(\begin{array}{c}
S_\rho \\
\Sb_{\ub} \\
S_p \\
S_{\rho e} \\
S_{A_k} \\
S_{X_k} \\
S_{Y_k}
\end{array}\right)^n
=
\left(\begin{array}{c}
S_{{\rm ext},\rho} \\
\gb + \frac{1}{\rho}\Sb_{{\rm ext},\rho\ub} \\
\frac{1}{\rho}\frac{\partial p}{\partial e}S_{{\rm ext},\rho E} + \frac{\partial p}{\partial\rho}S_{{\rm ext}\rho} \\
\nabla\cdot\kappa\nabla T + S_{{\rm ext},\rho E} \\
\frac{1}{\rho}S_{{\rm ext},\rho A_k} \\
\frac{1}{\rho}S_{{\rm ext},\rho X_k} \\
\frac{1}{\rho}S_{{\rm ext},\rho Y_k}
\end{array}\right)^n,
\end{equation}
\begin{equation}
\Sb_{\Ub}^n =
\left(\begin{array}{c}
\Sb_{\rho\ub} \\
S_{\rho E} \\
S_{\rho A_k} \\
S_{\rho X_k} \\
S_{\rho Y_k}
\end{array}\right)^n
=
\left(\begin{array}{c}
\rho \gb + \Sb_{{\rm ext},\rho\ub} \\
\rho \ub \cdot \gb + \nabla\cdot\kappa\nabla T + S_{{\rm ext},\rho E} \\
S_{{\rm ext},\rho A_k} \\
S_{{\rm ext},\rho X_k} \\
S_{{\rm ext},\rho Y_k}
\end{array}\right)^n.
\end{equation}

\item[Step 4:] {\em Advect $\Delta t$.}

The goal is to advance
\begin{equation}
\Ub^{n+1} = \Ub^n - \dt\nabla\cdot\Fb^\nph + \dt\Sb^n.
\end{equation}
neglecting reaction terms.  Note that since the source term is not
time centered, this is not a second-order method.  After the advective
update, we correct the solution, effectively time-centering the source
term. The advection step is complicated, and more detail is given in
Section \ref{Sec:Advection Step}.  Here is the summarized version:
\begin{enumerate}
\item Compute primitive variables.
\item Predict primitive variables to time-centered edges.
\item Solve the Riemann problem.
\item Compute fluxes and update.
\end{enumerate}
\item[Step 4:] {\em Solve for updated gravity.}

Solve for gravity using:
\begin{equation}
\gb^{n+1} = \nabla\phi^{n+1}; \qquad \Delta\phi^{n+1} = 4\pi G\rho^{n+1},
\end{equation}
or use one of the simpler gravity types.
\item[Step 6:] {\em Correct solution with time-centered source terms.}

We need to correct the solution by effectively time-centering the
source terms.  These corrections are to be performed sequentially
since new source term evaluations may depend on previous corrections.

First, we correct the solution with the updated gravity:
\begin{eqnarray}
(\rho\ub)^{n+1} &=& (\rho\ub)^{n+1} + \frac{\dt}{2}\left[(\rho\gb)^{n+1} - (\rho\gb)^n\right], \\
(\rho E)^{n+1} &=& (\rho E)^{n+1} + \frac{\dt}{2}\left[\left(\rho\ub\cdot\gb\right)^{n+1} - \left(\rho\ub\cdot\gb\right)^n\right].
\end{eqnarray}

Next, we correct $\Ub$ with updated external sources.  For example,
for the momentum, we correct using
\begin{equation}
(\rho\ub)^{n+1} = (\rho\ub)^{n+1} + \frac{\dt}{2}\left(\Sb_{{\rm ext},\rho\ub}^{n+1} - \Sb_{{\rm ext},\rho\ub}^n\right).
\end{equation}
We correct $\rho E, \rho A_k, \rho X_k$, and $\rho Y_k$ in an
analogous manner.

Finally, we correct the solution with updated thermal diffusion using
\begin{equation}
(\rho E)^{n+1} = (\rho E)^{n+1} + \frac{\dt}{2}\left(\nabla\cdot\kappa\nabla T^{n+1} - \nabla\cdot\kappa\nabla T^n\right).
\end{equation}
\item[Step 7:] {\em React $\Delta t/2$.}

Update the solution due to the effect of reactions over half a time step.
\begin{eqnarray}
(\rho E)^{n+1} &=& (\rho E)^{n+1} - \frac{\dt}{2}\sum_k(\rho q_k\omegadot_k)^{n+1},\\
(\rho X_k)^{n+1} &=& (\rho X_k)^{n+1} + \frac{\dt}{2}(\rho\omegadot_k)^{n+1}.
\end{eqnarray}
\item[Step 8:] {\em Modify auxiliary variables.}

This is problem-dependent.  By default we treat the auxiliary
variables as advected quantities, so no additional steps are required.

\item[Step 9:] {\em Optionally, retry the timestep from Step 1.}

If the timestep that you took had a timestep that was not sufficient to
enforce the stability criteria that you would like to achieve, such as
the CFL criterion for hydrodynamics or the burning stability criterion
for reactions, you can retry the timestep by setting {\tt castro.use\_retry = 1}
in your inputs file. This will save the current state data at the beginning
of the level advance, and then if the criteria are not satisfied, will
reject that advance and start over from the old data, with a series of
subcycled timesteps that should be small enough to satisfy the criteria.
Note that this will effectively double the memory footprint on each level
if you choose to use it.

\end{enumerate}
Thus concludes the single-level algorithm description.


There are a number of parameters that affect which physics is turned on:
\begin{itemize}
\item {\tt castro.do\_hydro}
\item {\tt castro.do\_react}
\end{itemize}


\section{Outline of {\tt Castro::advance()}}

\MarginPar{this seems out of date}

\noindent

if (doReact)

\hspace{.1in}  strangChem()

end if

if (doGrav)

\hspace{.1in}  define oldGravityVector

end if

if (Diffusion)

\hspace{.1in}  getOldDiffusionTerm()

end if

if (addExtSource)

\hspace{.1in}  getSource() at old time

end if

AdvanceSolution()

if (doGrav)

\hspace{.1in}  define newGravityVector

\hspace{.1in}  correct solution due to new gravity

end if

if (addExtSource)

\hspace{.1in}  getSource() at new time

\hspace{.1in}  correct solution due to new source

end if

if (Diffusion)

\hspace{.1in}  getNewDiffusionTerm()

\hspace{.1in}  correct solution due to new diffusion term

\hspace{.1in}  computeTemp()

end if

if (doReact)

\hspace{.1in}  strangChem()

end if

if (advanceAux)

\hspace{.1in}  advanceAux()

end if

if (LevelSet)

\hspace{.1in}  advanceLevelSet()

end if

