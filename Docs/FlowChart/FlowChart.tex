\section{Primary Data-structures}

\castro\ is built on the \cpp\ \boxlib\ framework, and relies on the
{\tt Amr} class defined there to drive the simulation.

The following other classes / concepts also play a major role laying
out \castro's algorithm:
\begin{itemize}
\item \code{AmrLevel} : this is a class that has the whole fluid state \MarginPar{more}

\item \code{Castro} : this is an {\tt AmrLevel}-derived class for a
  single level---it contains all the data needed to advance the state
  for a single level

\item \code{MultiFab} : this is the collection of boxes (w/ data) at the 
  same level of refinement.  A \tt {\tt MultiFab} can have multiple
  components, ghost cells, etc.  \MarginPar{what else? does it know about boundaries?}

\item \code{\statedata}

\end{itemize}


\section{Overview of a single step (no SDC)}

The main evolution for a single step is contained in
\code{Castro\_advance.cpp}, as \code{Castro::advance()}.  This does
the following advancement.  Note, some parts of this are only done
depending on which preprocessor directives are defined at
compile-time---the relevant directive is noted in the [\ ] at the start
of each step.

\begin{enumerate}
\item {\em Initialization} 

  This sets up the current level for advancement.  If we are at the
  start of a coarse level timestep, or we are in the middle of
  subcycling on a finer level (\code{amr\_iteration} {\tt > 1}), then
  we swap the \statedata\ from the new to old (e.g., this ensures that
  the next evolution starts with the result from the previous step).

  This also syncs up the level information to the Fortran-side of
  \castro, does any radiation initialization, and initializes all of
  the intermediate storage arrays (like those that hold source terms,
  etc.).

\item {\em Advancement} 

  This is calls \code{do\_advance} to take a single step,
  incorporating hydrodynamics, reactions, and source terms.  For
  radiation-hydrodynamics, this step does the advective (hyperbolic)
  portion of the radiation update only.

  \MarginPar{Diffusion?}

  \MarginPar{where is gravity hooked in?}


  If \runparam{castro.use\_retry} is set, then we subcycle the current
  step if we violated any stability criteria to reach the desired
  $\Delta t$. \MarginPar{more?}

If the timestep that you took had a timestep that was not sufficient to
enforce the stability criteria that you would like to achieve, such as
the CFL criterion for hydrodynamics or the burning stability criterion
for reactions, you can retry the timestep by setting {\tt castro.use\_retry = 1}
in your inputs file. This will save the current state data at the beginning
of the level advance, and then if the criteria are not satisfied, will
reject that advance and start over from the old data, with a series of
subcycled timesteps that should be small enough to satisfy the criteria.
Note that this will effectively double the memory footprint on each level
if you choose to use it.


\item {[\ifdef{AUX\_UPDATE}]} {\em Auxillary quantitiy evolution} 

  Auxillary variables in Castro are those that obey a continuity
  equation (with optional sources) that are passed into the EOS, but
  not subjected to the constraint on mass fractions (summing to one).

  The advection and source terms are already dealt with in the 
  main hydrodynamics advance (above step).  A user-supplied routine
  \code{ca\_auxupdate} can be provided here to further update these
  quantities.
  
\item {[\ifdef{LEVELSET}]} {\em Levelsets} 

  Basic support for level sets was added to \castro, but is not currently
  supported.  This is the hook for where the advancement would be done.

\item {\em Radial data and {\rm[\ifdef{POINTMASS}]} point mass} 

  If \runparam{castro.spherical\_star} is set, then we average the state data
  over angles here to create a radial profile.  This is then used in the 
  boundary filling routines to properly set Dirichlet BCs when our domain
  is smaller than the star, so the profile on the boundaries will not 
  be uniform.

  If \runparam{castro.point\_mass\_fix\_solution} is set, then we
  change the mass of the point mass that optionally contributes to the
  gravitational potential by taking mass from the surrounding zones
  (keeping the density in those zones constant).

\item {[\ifdef{RADIATION}]} {\em Radiation implicit update} 

  The {\tt do\_advance()} routine only handled the hyperbolic
  portion of the radiation update.  This step does the implicit solve
  (either gray or multigroup) to advance the radiation energies to the 
  new time level.  Note that at the moment, this is backward-difference
  implicit (first-order in time) for stability.

  This is handled by \code{final\_radiation\_call()}.

\item {[\ifdef{PARTICLES}]} {\em Particles} 

  If we are including passively-advected particles, they are
  advanced in this step.

\item {\em Finalize}

  This cleans up the memory used during the step.  

  If \runparam{castro.track\_grid\_losses} is set, then we also add up
  the mass that left through the boundary over this step. \MarginPar{do this use masks to ensure no double counting if multiple levels touch the boundary?}

\end{enumerate}

\subsection{Main Hydro, Reaction, and Gravity Advancement (Strang-splitting)}

The explicit portion of the system advancement (reactions,
hydrodynamics, and gravity) is done by \code{do\_advance()}.  
Consider our system of equations as:
\begin{equation}
\frac{\partial\Ub}{\partial t} = \nabla\cdot\Fb + \Sb_{\rm react} + \Sb,
\end{equation}
where $\Fb$ is the flux vector, $\Sb_{\rm react}$ are the reaction
source terms, and $\Sb$ are the non-reaction source terms, which
includes any user-defined external sources, $\Sb_{\rm ext}$.  We use
Strang splitting to discretize the advection-reaction equations.  In
summary, for each time step, we update the conservative variables,
$\Ub$, by reacting for half a time step, advecting for a full time
step (ignoring the reaction terms), and reacting for half a time step.
The treatment of source terms complicates this a little.  The actual
update, in sequence, looks like:
\begin{align}
\Ub^\star &= \Ub^n + \frac{\dt}{2}\Sb_{\rm react}(\Ub^n) \\
\Ub^{n+1,(a)} &= \Ub^\star + \dt\, \Sb(\Ub^\star) \\
\Ub^{n+1,(b)} &= \Ub^{n+1,(a)} - \dt\, {\bf A}(\Ub^\star) \\
\Ub^{n+1,(c)} &= \Ub^{n+1,(b)} + \frac{\dt}{2}\, [\Sb(\Ub^{n+1,(b)}) - \Sb(\Ub^\star)] \label{eq:source_correct}\\
\Ub^{n+1}     &= \Ub^{n+1,(c)} + \frac{\dt}{2} \Sb_{\rm react}(\Ub^{n+1,(c)})
\end{align}

The construction of the advective terms, ${\bf A(\Ub)}$ is purely
explicit, and based on an unsplit second-order Godunov method.  We
predict the standard primitive variables, as well as $\rho e$, at
time-centered edges and use an approximate Riemann solver construct
fluxes.

At the beginning of the time step, we assume that $\Ub$ and $\phi$ are
defined consistently, i.e., $\rho^n$ and $\phi^n$ satisfy equation
(\ref{eq:Self Gravity}).  Also note that in
Eq.~\ref{eq:source_correct}, we actually can do the new time-level
source updates in sequence (this is the default, and is controlled by
\runparam{castro.update\_state\_between\_sources}.  Additionally, some
terms, like rotation, can be treated implicitly.  Together, this can
make the update more akin to:
\begin{equation}
\Ub^{n+1,(c)} = \Ub^{n+1,(b)} + \frac{\dt}{2} [S(\Ub^{n+1,(c)}) - S(\Ub^n)]
\end{equation}

\castro\ also supports radiation.  This part of the update algorithm
only deals with the advective / hyperbolic terms in the radiation update.

Here is the single-level algorithm.  In the code, the objective is to
evolve the state from the old time, {\tt S\_old}, to the new time,
{\tt S\_new}.  \MarginPar{Sborder?}

\begin{enumerate}
\item {\em Initialize}

This resets the flux registers and initializes a lot of intermediate
storage arrays (like source term) to zero.

We also check for NaNs in the initial state, {\tt S\_old}.

\item {\em React $\Delta t/2$.}

Update the solution due to the effect of reactions over half a time
step.  The integration method and system of equations used here is
determined by a host of runtime parameters that are part of the
\microphysics\ package.  But the basic idea is to evolve the energy
release from the reactions, the species mass fractions, and
temperature through $\Delta t/2$.  

Using the notation above, we begin with the time-level $n$ state,
$\Ub^n$, and produce a state that has evolved only due to reactions,
$\Ub^\star$.

\begin{align}
(\rho e)^\star &= (\rho e)^\star - \frac{\dt}{2} \rho H_\mathrm{nuc} \\
(\rho E)^\star &= (\rho E)^\star - \frac{\dt}{2} \rho H_\mathrm{nuc} \\
(\rho X_k)^\star &= (\rho X_k)^\star + \frac{\dt}{2}(\rho\omegadot_k)^n.
\end{align}
Here, $H_\mathrm{nuc}$ is the energy release (erg/g/s) over the burn,
and $\omegadot_k$ is the creation rate for species $k$.

After exiting the burner, we call the EOS with $\rho^\star$,
$e^\star$, and $X_k^\star$ to get the new temperature, $T^\star$.

Note that the density, $\rho$, does not change via reactions in the
Strang-split formulation.


\item {\em Construct time-level $n$ sources and apply}

The time level $n$ sources are applied to the state after the burn, $\Ub^\star$, 
with a full $\Delta t$ weighting (this will be corrected later).  This produces
the intermediate state, $\Ub^{n+1,(a)}$.

The sources that we deal with here are:
\begin{enumerate}
  \item sponge : the sponge\index{sponge} is a damping term added to the 
     momentum equation that is designed to drive the velocities to zero
     over some timescale.  Our implementation of the sponge follows that
     of \maestro~\cite{maestro:III}

  \item external sources : users can define problem-specific sources
    in the \code{ext\_src\_?d.f90} file.  Sources for the different
    equations in the conservative state vector, $\Ub$, are indexed
    using the integer keys defined in {\tt meth\_params\_module}
    (e.g., {\tt URHO}).

    This is most commonly used for external heat sources (see the
    \problem{toy\_convect} problem setup) for an example.  But most
    problems will not use this.

  \item {[\ifdef{DIFFUSION}]} diffusion : thermal diffusion can be
    added in an explicit formulation.  Second-order accuracy is
    achieved by averaging the time-level $n$ and $n+1$ terms, using
    the same predictor-corrector strategy described here.

    Note: thermal diffusion is distinct from radiation hydrodynamics.

    Also note that incorporating diffusion brings in an additional
    timestep constraint, since the treatment is explicit.  See
    Chapter~\ref{ch:diffusion} for more details.  \MarginPar{this may not be time-centered correctly---see issue \# 22}

  \item {[\ifdef{HYBRID\_MOMENTUM}]} angular momentum 

    \MarginPar{need to write this up}

  \item {[\ifdef{GRAVITY}]} gravity:

    For full Poisson gravity, we solve for for gravity using:
    \begin{equation}
      \gb^n = -\nabla\phi^n, \qquad
      \Delta\phi^n = 4\pi G\rho^n,
    \end{equation}

    The construction of the form of the gravity source for the
    momentum and energy equation is dependent on the parameter
    \runparam{castro.grav\_source\_type}.  Full details of the gravity
    solver are given in Chapter~\ref{ch:gravity}.

    \MarginPar{we should add a description of whether we do a level solve or a composite solve}

    \MarginPar{what do we store? phi and g? source?}

  \item {[\ifdef{ROTATION}]} rotation

    We compute the rotational potential (for use in the energy update)
    and the rotational acceleration (for use in the momentum
    equation).  This includes the Coriolis and centrifugal terms in a
    constant-angular-velocity co-rotating frame.  The form of the
    rotational source that is constructed then depends on the
    parameter \runparam{castro.rot\_source\_type}.  More details are
    given in Chapter~\ref{ch:rotation}.
    
\end{enumerate}

The source terms here are evaluated using the post-burn state,
$\Ub^\star$, and later corrected by using the new state just before
the burn, $\Ub^{n+1,(b)}$.  This is compatible with Strang-splitting,
since the hydro and sources takes place completely inside of the
surrounding burn operations.

\item {\em Construct the hydro update}

The goal is to advance our system considering only the advective terms
(which in Cartesian coordinates can be written as the divergence of a
flux).  

We do the hydro update in two parts---first we construct the advective
update and store it, then we do the conservative update in a separate
step.  This separation allows us to use the advective update
separately in more complex time-integration schemes.

In the Strang-split formulation, we start the reconstruction using the
state after burning, $\Ub^\star$, and predict to the half-time
($n+1/2$) to get a second-order accurate method.  The advection step
is complicated, and more detail is given in Section \ref{Sec:Advection
  Step}.
Here is the summarized version:
\begin{enumerate}
\item Compute primitive variables.
\item Predict primitive variables to time-centered edges.
\item Solve the Riemann problem.
\item Compute fluxes and update.
\end{enumerate}

To start the hydrodynamics, we need to know the hydrodynamics source
terms at time-level $n$, since this enters into the prediction to the
interface states.  This is essentially the same vector that was
computed in the previous step, with a few modifications.  The most
important is that if we set \runparam{castro.source\_term\_predictor},
then we extrapolate the source terms from $n$ to $n+1/2$, using the
change from the previous step. 

Note: we neglect the reaction source terms, since those are already
accounted for in the state directly, due to the Strang-splitting 
nature of this method.


\item {\em Update radial data and center of mass for monopole gravity}
 \MarginPar{is that right?}


\item {\em Clean State}

Need to describe this

Also check for NaNs.


\item {\em Correct the source terms with the $n+1$ contribution}

Previously we added $\Delta t S^n$ to the state, when we really want
a time-centered approach, $(\Delta t/2)(S^n + S^{n+1})$.  We fix 
that here.

We start by compute the source term vector $S^{n+1}$ using the 
updated data, $U^{n+1,\star}$.  We then compute the correction,
$(\Delta t/2)(S^{n+1} - S^n)$ to add to $U^{n+1,\star}$ to
give us the properly time-centered source, $U^{n+1}$.

We have a choice of how to do this correction.  We can first compute
all the corrections using the same initial state, $U^{n+1,\star}$, and
then apply them all.  Or we can compute them one-by-one applying them
as we go.  This behavior is controlled by the parameter
\runparam{castro.update\_state\_between\_sources}.

In the process of updating the sources, we update the temperature
to make it consistent with the new state.

%% We need to correct the solution by effectively time-centering the
%% source terms.  These corrections are to be performed sequentially
%% since new source term evaluations may depend on previous corrections.

%% First, we correct the solution with the updated gravity:
%% \begin{eqnarray}
%% (\rho\ub)^{n+1} &=& (\rho\ub)^{n+1} + \frac{\dt}{2}\left[(\rho\gb)^{n+1} - (\rho\gb)^n\right], \\
%% (\rho E)^{n+1} &=& (\rho E)^{n+1} + \frac{\dt}{2}\left[\left(\rho\ub\cdot\gb\right)^{n+1} - \left(\rho\ub\cdot\gb\right)^n\right].
%% \end{eqnarray}

%% Next, we correct $\Ub$ with updated external sources.  For example,
%% for the momentum, we correct using
%% \begin{equation}
%% (\rho\ub)^{n+1} = (\rho\ub)^{n+1} + \frac{\dt}{2}\left(\Sb_{{\rm ext},\rho\ub}^{n+1} - \Sb_{{\rm ext},\rho\ub}^n\right).
%% \end{equation}
%% We correct $\rho E, \rho A_k, \rho X_k$, and $\rho Y_k$ in an
%% analogous manner.

%% Finally, we correct the solution with updated thermal diffusion using
%% \begin{equation}
%% (\rho E)^{n+1} = (\rho E)^{n+1} + \frac{\dt}{2}\left(\nabla\cdot\kappa\nabla T^{n+1} - \nabla\cdot\kappa\nabla T^n\right).
%% \end{equation}


\item {\em React $\Delta t/2$.}

Update the solution due to the effect of reactions over half a time step.
\begin{eqnarray}
(\rho E)^{n+1} &=& (\rho E)^{n+1} - \frac{\dt}{2}\sum_k(\rho q_k\omegadot_k)^{n+1},\\
(\rho X_k)^{n+1} &=& (\rho X_k)^{n+1} + \frac{\dt}{2}(\rho\omegadot_k)^{n+1}.
\end{eqnarray}


\item {\em Finalize}

TBD



\end{enumerate}

