

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Software Design &mdash; Castro 2.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Frequently Asked Questions" href="faq.html" />
    <link rel="prev" title="Flowchart" href="FlowChart.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Castro
          

          
          </a>

          
            
            
              <div class="version">
                2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Castro basics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction to Castro</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="inputs.html">Input Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="rp_intro.html">Runtime Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="FlowChart.html">Flowchart</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Software Design</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#code-structure">Code structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#major-data-structures">Major data structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#amr">Amr</a></li>
<li class="toctree-l3"><a class="reference internal" href="#amrlevel-and-castro-classes">AmrLevel&nbsp;and Castro classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#floating-point-data">Floating point data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#box-and-farraybox">Box&nbsp;and FArrayBox</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multifab">MultiFab</a></li>
<li class="toctree-l3"><a class="reference internal" href="#statedata">StateData</a></li>
<li class="toctree-l3"><a class="reference internal" href="#various-source-multifabs">Various source MultiFabs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mfiter-and-interacting-with-fortran">MFIter&nbsp;and interacting with Fortran</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#non-tiling-mfiter">Non-Tiling MFIter</a></li>
<li class="toctree-l3"><a class="reference internal" href="#amrexs-current-tiling-approach-in-c">AMReX’s Current Tiling Approach In C++</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#practical-details-in-working-with-tiling">Practical Details in Working with Tiling</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#boundaries-fillpatch-and-fillpatchiterator">Boundaries: FillPatch and FillPatchIterator</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#examples">Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="#physical-boundaries">Physical Boundaries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fluxregister">FluxRegister</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#other-amrex-concepts">Other AMReX&nbsp;Concepts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#geometry-class">Geometry class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parmparse-class">ParmParse class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#error-estimators">Error Estimators</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#gravity-class">Gravity class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fortran-helper-modules">Fortran Helper Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#setting-up-your-own-problem">Setting Up Your Own Problem</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#optional-files">Optional Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dimension-agnostic-problem-initialization">Dimension Agnostic Problem Initialization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#parallel-i-o">Parallel I/O</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="Hydrodynamics.html">Hydrodynamics</a></li>
<li class="toctree-l1"><a class="reference internal" href="gravity.html">Gravity</a></li>
<li class="toctree-l1"><a class="reference internal" href="diffusion.html">Diffusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="rotation.html">Rotation</a></li>
<li class="toctree-l1"><a class="reference internal" href="radiation.html">Radiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="Particles.html">Tracer particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="EOSNetwork.html">Microphysics</a></li>
<li class="toctree-l1"><a class="reference internal" href="AMR.html">Adaptive Mesh Refinement</a></li>
<li class="toctree-l1"><a class="reference internal" href="ConvertCheckpoint.html">Checkpoint Embiggener</a></li>
<li class="toctree-l1"><a class="reference internal" href="MAESTRO_restart.html">Restarting from Maestro</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
<p class="caption"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="filelist.html">File list</a></li>
<li class="toctree-l1"><a class="reference internal" href="classlist.html">Class list</a></li>
<li class="toctree-l1"><a class="reference internal" href="namespacelist.html">Namespace list</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Castro</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Software Design</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/software.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

/* nice headers on first paragraph of info/warning boxes */
.admonition .first {
    margin: -12px;
    padding: 6px 12px;
    margin-bottom: 12px;
    color: #fff;
    line-height: 1;
    display: block;
}
.admonition.warning .first {
    background: #f0b37e;
}
.admonition.note .first {
    background: #6ab0de;
}
.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}
</style>
<div class="section" id="software-design">
<h1>Software Design<a class="headerlink" href="#software-design" title="Permalink to this headline">¶</a></h1>
<div class="section" id="code-structure">
<h2>Code structure<a class="headerlink" href="#code-structure" title="Permalink to this headline">¶</a></h2>
<p>Castro&nbsp;is built upon the AMReX&nbsp;C&nbsp;framework. This provides
high-level classes for managing an adaptive mesh refinement
simulation, including the core data structures we will deal with. A
key design pattern in AMReX&nbsp;is that the overall memory management
and parallelization is done in the C&nbsp;layer, while the heavy
computational work is done in Fortran kernels. AMReX&nbsp;provides
convenient data structures that allow for this workflow—high level
objects in C&nbsp;that communicate with Fortran through pointers to
data regions that appear as multidimensional arrays.</p>
<p>Castro&nbsp;uses a structured-grid approach to hydrodynamics. We work
with square/cubic zones that hold state variables (density, momentum,
etc.) and compute the fluxes of these quantities through the
interfaces of the zones (this is a finite-volume approach).
Parallelization is achieved by domain decomposition. We divide our
domain into many smaller boxes, and distributed these across
processors. When information is needed at the boundaries of the
boxes, messages are exchanged and this data is held in a perimeter of
<em>ghost cells</em>. AMReX&nbsp;manages this decompostion and
communication for us. Additionally, AMReX&nbsp;implements adaptive mesh
refinement. In addition to the coarse decomposition of our domain
into zones and boxes, we can refine rectangular regions by adding
finer-gridded boxes on top of the coarser grid. We call the
collection of boxes at the same resolution a <em>level</em>.</p>
<p>Castro&nbsp;uses a hybrid MPI + OpenMP approach to parallelism. MPI is
at used to communicate across nodes on a computer and OpenMP is used
within a node, to loop over subregions of a box with different
threads.</p>
<p>The code structure in the Castro/ directory reflects the
division between C&nbsp;and Fortran.</p>
<ul class="simple">
<li>constants/: contains a file of useful constants in CGS units</li>
<li>Docs/: you’re reading this now!</li>
<li>Exec/: various problem implementations, sorted by category:<ul>
<li>gravity_tests/: test problems that primarily exercise the gravity solver</li>
<li>hydro_tests/: test problems of the hydrodynamics (with or without reactions)</li>
<li>radiation_tests/: test problems that primarily exercise the radiation hydrodynamics solver</li>
<li>science/: problem setups that were used for scientific investigations</li>
<li>unit_tests/: test problems that exercise primarily a single module</li>
</ul>
</li>
<li>Microphysics/: contains directories for different default
microphysics (these are all implemented in Fortran)<ul>
<li>conductivity/: the thermal conductivity</li>
<li>EOS/: the equation of state</li>
<li>networks/: the nuclear reaction networks</li>
<li>opacity/: the radiative opacity (used with radiation)</li>
<li>viscosity/: the viscous transport coefficient</li>
</ul>
</li>
<li>Source/: source code. In this main directory is all of
the code. Sources are mixed C&nbsp;and Fortran and are organized by topic as:<ul>
<li>diffusion/ : thermal diffusion code</li>
<li>driver/ : the main driver, I/O, runtime parameter support</li>
<li>gravity/ : self-gravity code</li>
<li>hydro/ : the compressible hydrodynamics code</li>
<li>particles/ : support for particles</li>
<li>problems/ : template code for implementing a problem</li>
<li>radiation/ : the implicit radiation solve code</li>
<li>reactions/ : nuclear reaction code</li>
<li>rotation/ : rotating code</li>
<li>sources/ : hydrodynamics source terms support</li>
</ul>
</li>
<li>Util/: a catch-all for additional things you may need<ul>
<li>ConvertCheckpoint/: a tool to convert a checkpoint file to
a larger domain</li>
<li><span class="math notranslate nohighlight">\(\ldots\)</span></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="major-data-structures">
<h2>Major data structures<a class="headerlink" href="#major-data-structures" title="Permalink to this headline">¶</a></h2>
<p>The following data structures are the most commonly encountered when
working in the C&nbsp;portions of Castro. This are all
AMReX&nbsp;data-structures / classes.</p>
<div class="section" id="amr">
<h3>Amr<a class="headerlink" href="#amr" title="Permalink to this headline">¶</a></h3>
<p>This is the main class that drives the whole simulation. This is
the highest level in Castro.</p>
</div>
<div class="section" id="amrlevel-and-castro-classes">
<h3>AmrLevel&nbsp;and Castro classes<a class="headerlink" href="#amrlevel-and-castro-classes" title="Permalink to this headline">¶</a></h3>
<p>An is a virtual base class provided by AMReX&nbsp;that
stores all the state data on a single level in the AMR hierarchy and
understands how to advance that data in time.</p>
<p>The most important data managed by the AmrLevel&nbsp;is an array of
StateData, which holds the fluid quantities, etc., in the boxes
that together make up the level.</p>
<p>The Castro class is derived from the AmrLevel. It provides
the Castro-specific routines to evolve our system of equations. Like
the AmrLevel, there is one Castro object for each level in the
AMR hierarchry.</p>
<p>A lot of the member data in the Castro class are static member
variables—this means that they are shared across all instances of
the class. So, in this case, every level will have the same data.
This is done, in particular, for the values of the runtime parameters,
but also for the Gravity, Diffusion, and Radiation
objects. This means that those objects cover all levels and are the
same object in each instantiation of the Castro class.</p>
</div>
<div class="section" id="floating-point-data">
<h3>Floating point data<a class="headerlink" href="#floating-point-data" title="Permalink to this headline">¶</a></h3>
<p>Floating point data in the C&nbsp;AMReX&nbsp;frame work is declared as
Real. This is typedef to either float or
double depending on the make variable PRECISION.</p>
<p>The corresponding type for Fortran is provided by the
bl_fort_module as c_real. We typically rename
this to rt when using it. An example of a declaration of a
parameter is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">use</span> <span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">rt</span> <span class="o">=&gt;</span> <span class="n">amrex_real</span>

<span class="n">real</span><span class="p">(</span><span class="n">rt</span><span class="p">)</span> <span class="p">::</span> <span class="n">tol</span> <span class="o">=</span> <span class="mf">1.0e-10</span><span class="n">_rt</span>
</pre></div>
</div>
<p>The bl_constants_module provides common constants that can
be used in the code, like ZERO, THIRD, ONE, etc.</p>
<p>Note: single precision support in Castro&nbsp;is not yet complete. In
particular, a lot of the supporting microphysics has not been updated.</p>
</div>
<div class="section" id="box-and-farraybox">
<h3>Box&nbsp;and FArrayBox<a class="headerlink" href="#box-and-farraybox" title="Permalink to this headline">¶</a></h3>
<p>A is simply a rectangular region in space. It does not hold
data. In AMReX, an AMR level has a global index space, with
<span class="math notranslate nohighlight">\((0,0,0)\)</span> being the lower left corner of the domain at that level, and
<span class="math notranslate nohighlight">\((N_x-1, N_y-1, N_z-1)\)</span> being the upper right corner of the domain
(for a domain of <span class="math notranslate nohighlight">\(N_x \times N_y \times N_z\)</span> zones). The location of
any Box&nbsp;at a level can be uniquely specified with respect to this
global index space by giving the index of its lower-left and
upper-right corners. Figure&nbsp;<a class="reference external" href="#fig:soft:indexspace">[fig:soft:indexspace]</a> shows an
example of three boxes at the same level of refinement.</p>
<p>AMReX&nbsp;provides other data structures that collect Boxes together,
most importantly the . We generally do not use these
directly, with the exception of the BoxArray&nbsp;grids,
which is defined as part of the AmrLevel&nbsp;class that Castro
inherits. grids is used when building new MultiFabs to give
the layout of the boxes at the current level.</p>
<p>A or <em>FAB</em>, for <em>Fortran array box</em> is a data
structure that contains a Box&nbsp;locating it in space, as well as a
pointer to a data buffer. The real floating point data are stored as
one-dimensional arrays in FArrayBoxes. The associated Boxcan be
used to reshape the 1D array into multi-dimensional arrays to be used
by Fortran subroutines. The key part of the C&nbsp;AMReX&nbsp;data
structures is that this data buffer can be sent to Fortran, where it
will appear as a DIM+1 dimensional array (DIM space + 1
component).</p>
<p>Note: Castro&nbsp;is complied for a specific dimensionality.</p>
</div>
<div class="section" id="multifab">
<h3>MultiFab<a class="headerlink" href="#multifab" title="Permalink to this headline">¶</a></h3>
<p>At the highest abstraction level, we have the (mulitple
FArrayBoxes). A MultiFab&nbsp;contains an array of Boxes, including
Boxes owned by other processors for the purpose of communication,
an array of MPI ranks specifying which MPI processor owns each Box,
and an array of pointers to FArrayBoxes owned by this MPI
processor. Note: a
MultiFab&nbsp;is a collection of the boxes that together make up a single
level of data in the AMR hierarchy.</p>
<p>A MultiFab&nbsp;can have multiple components (like density, temperature,
…) as well as a perimeter of ghost cells to exchange data with
neighbors or implement boundary conditions (this is all reflected in
the underlying FArrayBox).</p>
<p>Parallelization in AMReX&nbsp;is done by distributing the FABs across
processors. Each processor knows which FABs are local to it. To loop
over all the boxes local to a processor, an MFIter&nbsp;is used (more
on this below).</p>
<p>High-level operations exist on MultiFabs to add, subtract, multiply,
etc., them together or with scalars, so you don’t need to write out
loops over the data directly.</p>
<p>In Castro, MultiFabs are one of the main data structures you will
interact with in the C&nbsp;portions of the code.</p>
</div>
<div class="section" id="statedata">
<span id="soft-sec-statedata"></span><h3>StateData<a class="headerlink" href="#statedata" title="Permalink to this headline">¶</a></h3>
<p>is a class that essentially holds a pair of MultiFabs: one
at the old time and one at the new time. AMReX&nbsp;knows how to
interpolate in time between these states to get data at any
intermediate point in time. The main data that we care about in
Castro&nbsp;(the fluid state, gravitational potential, etc.) will be
stored as StateData. Essentially, data is made StateData&nbsp;in
Castro&nbsp;if we need it to be stored in checkpoints / plotfiles, and/or
we want it to be automatically interpolated when we refine.</p>
<p>An AmrLevel&nbsp;stores an array of StateData&nbsp;(in a C&nbsp;array
called state). We index this array using integer keys (defined
via an enum in Castro.H). The state data is registered
with AMReX&nbsp;in Castro_setup.cpp.</p>
<p>Note that each of the different StateData&nbsp;carried in the state
array can have different numbers of components, ghost cells, boundary
conditions, etc. This is the main reason we separate all this data
into separate StateData&nbsp;objects collected together in an indexable
array.</p>
<p>The current StateData&nbsp;names Castro&nbsp;carries are:</p>
<ul>
<li><p class="first">State_Type : this is the NUM_STATE hydrodynamics
components that make up the conserved hydrodynamics state (usually
referred to as <span class="math notranslate nohighlight">\(\Ub\)</span> in these notes. But note that this does
not include the radiation energy density.</p>
<p>In Fortran, the components of a FAB derived from State_Type
is indexed using the integer keys defined in Castro_nd.F90
and stored in meth_params_module, e.g., URHO, UMX,
UMY, …</p>
<p>Note: regardless of dimensionality, we always carry around all
three velocity components. The “out-of-plane” components
will simply be advected, but we will allow rotation (in particular,
the Coriolis force) to affect them.</p>
<p>State_Type MultiFabs have no ghost cells by default for
pure hydro and a single ghost cell by default when RADIATION
is enabled. There is an option to force them to have ghost cells by
setting the parameter castro.state_nghost at runtime.</p>
<p>Note that the prediction of the hydrodynamic state to the interface
will require 4 ghost cells. This accomodated by creating a separate
MultiFab, Sborder that lives at the old-time level and
has the necessary ghost cells. We will describe this more later.</p>
</li>
<li><p class="first">Rad_Type : this stores the radiation energy density,
commonly denoted <span class="math notranslate nohighlight">\(E_r\)</span> in these notes. It has nGroups
components—the number of energy groups used in the multigroup
radiation hydrodynamics approximation.</p>
</li>
<li><p class="first">PhiGrav_Type : this is simply the gravitational
potential, usually denoted <span class="math notranslate nohighlight">\(\Phi\)</span> in these notes.</p>
</li>
<li><p class="first">Gravity_Type : this is the gravitational
acceleration. There are always 3 components, regardless of the
dimensionality (consistent with our choice of always carrying all 3
velocity components).</p>
</li>
<li><p class="first">PhiRot_Type : this is the rotational potential.
When rotation is enabled, this will store the effective potential
corresponding to the centrifugal force.</p>
</li>
<li><p class="first">Rotation_Type : this is the rotational acceleration.
There are always 3 components, regardless of the dimensionality
(consistent with our choice of always carrying all 3 velocity
components). This includes the terms corresponding to the Coriolis
force, the centrifugal force, as well as optional terms due to the
change in rotation rate, <span class="math notranslate nohighlight">\(\Omega\)</span>.</p>
</li>
<li><p class="first">Source_Type : this holds the time-rate of change of
the source terms, <span class="math notranslate nohighlight">\(d\Sb/dt\)</span>, for each of the NUM_STATE
State_Type variables.</p>
<p>Note: we do not make use of the old-time quantity here. In fact, we
never allocate the FArrayBoxs for the old-time in the Source_Type
StateData, so there is not wasted memory.</p>
</li>
<li><p class="first">Reactions_Type : this holds the data for the nuclear
reactions. It has NumSpec+2 components: the species
creation rates (usually denoted <span class="math notranslate nohighlight">\(\omegadot_k\)</span> in these notes),
the specific energy generation rate (<span class="math notranslate nohighlight">\(\dot{e}_\mathrm{nuc}\)</span>),
and its density (<span class="math notranslate nohighlight">\(\rho \dot{e}_\mathrm{nuc}\)</span>).</p>
<p>These are stored as StateData&nbsp;so we have access to the reaction terms
outside of advance, both for diagnostics (like flame speed estimation)
and for reaction timestep limiting (this in particular needs the
data stored in checkpoints for continuity of timestepping upon restart).</p>
</li>
<li><p class="first">SDC_React_Type : this is used with the SDC
time-advancement algorithm. This stores the QVAR terms
that describe how the primitive variables change over the timestep
due only to reactions. These are used when predicting the interface
states of the primitive variables for the hydrodynamics portion of the
algorithm.</p>
</li>
</ul>
<p>We access the multifabs that carry the data of interest by interacting
with the StateData&nbsp;using one of these keys. For instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MultiFab</span><span class="o">&amp;</span> <span class="n">S_new</span> <span class="o">=</span> <span class="n">get_new_data</span><span class="p">(</span><span class="n">State_Type</span><span class="p">);</span>
</pre></div>
</div>
<p>gets a pointer to the multifab containing the hydrodynamics state data
at the new time.</p>
</div>
<div class="section" id="various-source-multifabs">
<h3>Various source MultiFabs<a class="headerlink" href="#various-source-multifabs" title="Permalink to this headline">¶</a></h3>
<p>There are a number of different MultiFabs (and arrays of MultiFabs)
that hold source term information.</p>
<ul>
<li><p class="first">hydro_source : this is a MultiFab&nbsp;that holds the
update to the hydrodynamics (basically the divergence of the
fluxes). This is filled in the conservative update routine of the
hydrodynamics.</p>
<p>As this is expressed as a source term, what is actually stored is</p>
<div class="math notranslate nohighlight">
\[\Sb_\mathrm{flux} = -\nabla \cdot {\bf F}\]</div>
<p>So the update of the conserved state appears as:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \Ub}{\partial t} = \Sb_\mathrm{flux}\]</div>
</li>
<li><p class="first">sources_for_hydro : a single MultiFab&nbsp;that stores
the sum of sources over each physical process.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="mfiter-and-interacting-with-fortran">
<h2>MFIter&nbsp;and interacting with Fortran<a class="headerlink" href="#mfiter-and-interacting-with-fortran" title="Permalink to this headline">¶</a></h2>
<p>The process of looping over boxes at a given level of refinement and
operating on their data in Fortran is linked to how Castro&nbsp;achieves
thread-level parallelism. The OpenMP approach in Castro&nbsp;has evolved
considerably since the original paper was written, with the modern
approach, called <em>tiling</em>, gearing up to meet the demands of
many-core processors in the next-generation of supercomputers. We
discuss the original and new approach together here.</p>
<p>In both cases, the key construct is the —this is a
C&nbsp;iterator that knows how to loop over the FArrayBoxes in the
MultiFab&nbsp;that are local to the processor (in this way, a lot of the
parallelism is hidden from view).</p>
<div class="section" id="non-tiling-mfiter">
<h3>Non-Tiling MFIter<a class="headerlink" href="#non-tiling-mfiter" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>The non-tiling way to iterate over the FArrayBoxs is</dt>
<dd><a class="footnote-reference" href="#id6" id="id1">[1]</a>:</dd>
</dl>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf</span><span class="p">);</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span> <span class="c1">// Loop over boxes</span>
<span class="p">{</span>
  <span class="c1">// Get the index space of this iteration</span>
  <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">validbox</span><span class="p">();</span>

  <span class="c1">// Get a reference to the FAB, which contains data and box</span>
  <span class="n">FArrayBox</span><span class="o">&amp;</span> <span class="n">fab</span> <span class="o">=</span> <span class="n">mf</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span>

  <span class="c1">// Get the index space for the data region in th FAB.</span>
  <span class="c1">// Note &quot;abox&quot; may have ghost cells, and is thus larger than</span>
  <span class="c1">// or equal to &quot;box&quot; obtained using mfi.validbox().</span>
  <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">abox</span> <span class="o">=</span> <span class="n">fab</span><span class="p">.</span><span class="n">box</span><span class="p">();</span>

  <span class="c1">// We can now pass the information to a Fortran routine,</span>
  <span class="c1">// fab.dataPtr() gives a double*, which is reshaped into</span>
  <span class="c1">// a multi-dimensional array with dimensions specified by</span>
  <span class="c1">// the information in &quot;abox&quot;. We will also pass &quot;box&quot;,</span>
  <span class="c1">// which specifies our &quot;work&quot; region.</span>
  <span class="n">do_work</span><span class="p">(</span><span class="n">ARLIM_3D</span><span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">loVect</span><span class="p">()),</span> <span class="n">ARLIM_3D</span><span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">hiVect</span><span class="p">()),</span>
          <span class="n">fab</span><span class="p">.</span><span class="n">dataPtr</span><span class="p">(),</span> <span class="n">fab</span><span class="p">.</span><span class="n">nComp</span><span class="p">(),</span>
          <span class="n">ARLIM_3D</span><span class="p">(</span><span class="n">abox</span><span class="p">.</span><span class="n">loVect</span><span class="p">()),</span> <span class="n">ARLIM_3D</span><span class="p">(</span><span class="n">abox</span><span class="p">.</span><span class="n">hiVect</span><span class="p">())</span>

<span class="p">}</span>
</pre></div>
</div>
<p>A few comments about this code</p>
<ul>
<li><p class="first">In this example, we are working off of a MultiFab&nbsp;named mf.
This could, for example, come from state data as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MultiFab</span><span class="o">&amp;</span> <span class="n">mf</span> <span class="o">=</span> <span class="n">get_old_data</span><span class="p">(</span><span class="n">State_Type</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">We are passing the data in mf one box at a time to the
Fortran function do_work.</p>
</li>
<li><p class="first">Here the MFIter&nbsp;iterator, mfi, will perform the loop
only over the boxes that are local to the MPI task. If there are 3
boxes on the processor, then this loop has 3 iterations.</p>
<p>++mfi iterates to the next FArrayBox&nbsp;owned by the
MultiFab&nbsp;mf, and mfi.isValid() returns false
after we’ve reached the last box contained in the MultiFab,
terminating the loop.</p>
</li>
<li><p class="first">box as returned from mfi.validbox() does not include
ghost cells. This is the valid data region only.
We can get the indices of the valid zones as box.loVect() and
box.hiVect().</p>
<p>In passing to the Fortran function, we use the macro
ARLIM_3D, defined in ArrayLim.H to pass the lo
and hi vectors as pointers to an int array. This array
is defined to always be 3D, with 0s substituted for the
higher dimension values if we are running in 1- or 2D.</p>
<p>Passing the data in this 3D fashion is a newer approach in Castro.
This enables writing <em>dimension agnostic code</em>. There are many
other approaches that will pass only the DIM values of
lo and hi using alternate macros in ArrayLim.H.</p>
</li>
<li><p class="first">fab.dataPtr() returns a double *—a pointer to the
data region. This is what is passed to Fortran.</p>
</li>
<li><p class="first">fab.nComp() gives an int—the number of components
in the MultiFab. This will be used for dimensioning in Fortran.</p>
</li>
<li><p class="first">To properly dimension the array in Fortran, we need the actual
bounds of the data region, including any ghost cells. This is the
Box&nbsp;abox, obtained as fab.box(). We pass the
lo and hi of the full data region as well.</p>
</li>
</ul>
<p>To properly compile, we need a prototype for the Fortran
function. These are placed in the _F.H files in the
Castro&nbsp;Source/ directory. Here’s the prototype for
our function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">do_work</span>
  <span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">lo</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">hi</span><span class="p">,</span>
   <span class="n">Real</span><span class="o">*</span> <span class="n">state</span><span class="p">,</span> <span class="k">const</span> <span class="n">Real</span><span class="o">&amp;</span> <span class="n">ncomp</span>
   <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">s_lo</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">s_hi</span><span class="p">)</span>
</pre></div>
</div>
<p>A few comments on the prototype:</p>
<ul class="simple">
<li>we use the const qualifier on the many of the arguments.
This indicates that the data that is pointed to cannot be
modified <a class="footnote-reference" href="#id7" id="id2">[2]</a>
means that the pointers themselves are to be unmodified. But the
contents of the memory space that they point to can be modified.</li>
<li>For ncomp, we in the calling sequence, we just did
fab.nComp(). This returns a int. But Fortran is a
pass-by-reference language, so we make the argument in the prototype
a reference. This ensures that it is passed by reference.</li>
</ul>
<p>In our Fortran example, we want to loop over all of the data,
including 1 ghost cell all around. The corresponding Fortran function
will look like:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">do_work</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="p">&amp;</span>
                   <span class="n">state</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="p">&amp;</span>
                   <span class="n">s_lo</span><span class="p">,</span> <span class="n">s_hi</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;do_work&quot;</span><span class="p">)</span>

  <span class="k">use </span><span class="n">prob_params_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">dg</span>

  <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
  <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">s_lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">s_hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">ncomp</span>

  <span class="kt">real</span> <span class="p">(</span><span class="nb">kind</span><span class="o">=</span><span class="n">dp_t</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">state</span><span class="p">(</span><span class="n">s_lo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">s_hi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="p">&amp;</span>
                                           <span class="n">s_lo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">s_hi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="p">&amp;</span>
                                           <span class="n">s_lo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">s_hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">ncomp</span><span class="p">)</span>

  <span class="c">! loop over the data</span>
  <span class="k">do </span><span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">dg</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="o">*</span><span class="n">dg</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
     <span class="k">do </span><span class="n">j</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">dg</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="o">*</span><span class="n">dg</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">dg</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="o">*</span><span class="n">dg</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

           <span class="c">! work on state(i,j,k,:), where the last index</span>
           <span class="c">! is the component of the multifab</span>

        <span class="n">enddo</span>
     <span class="n">enddo</span>
  <span class="n">enddo</span>

<span class="k">end subroutine </span><span class="n">do_work</span>
</pre></div>
</div>
<p>Finally, comments on the Fortran routine;</p>
<ul>
<li><p class="first">We use the Fortran 2003 bind keyword to specify
that we want this to be interoperable with C. Ordinarily
we would not need to specify the optional argument name
in the binding, but the PGI compiler requires this if our
Fortran subroutine is part of a module.</p>
</li>
<li><p class="first">We dimension state using s_lo and s_hi—these are
the bounds we got from the FArrayBox, and are for the entire data
region, including ghost cells.</p>
<p>Note, in Fortran, the spatial indices of state don’t
necessarily start at 1—they reflect the global index space
for the entire domain at this level of refinement. This means that
we know where the box is located.</p>
<p>Later we’ll see how to compute the spatial coordinates using this
information.</p>
</li>
<li><p class="first">Our loop uses lo and hi—these are the indices
of the valid data region (no ghost cells). Since we want a single
ghost cell all around, we subtract 1 from lo and add 1
to hi.</p>
<p>Finally, since this is dimension-agnostic code (it should work
correctly in 1-, 2-, and 3D), we need to ensure the loops over the
higher dimensions do nothing when we compile for a lower
dimensionality. This is the role of dg—dg is 1
if our simulation includes that spatial dimension and 0
otherwise.</p>
<p>If we were not looping over ghost cells too, then we would not need
to invoke dg, since lo and hi are both set to
0 for any dimensions not represented in our simulation.</p>
</li>
</ul>
<p>Up to this point, we have not said anything about threading. In this
style of using the MFIter, we implement the OpenMP in Fortran, for
instance by putting a pragma around the outer loop in this example.</p>
</div>
<div class="section" id="amrexs-current-tiling-approach-in-c">
<span id="sec-boxlib1"></span><h3>AMReX’s Current Tiling Approach In C++<a class="headerlink" href="#amrexs-current-tiling-approach-in-c" title="Permalink to this headline">¶</a></h3>
<p>There are two types of tiling that people discuss. In <em>logical
tiling</em>, the data storage in memory is unchanged from how we do things
now in pure MPI. In a given box, the data region is stored
contiguously). But when we loop in OpenMP over a box, the tiling
changes how we loop over the data. The alternative is called
<em>separate tiling</em>—here the data storage in memory itself is changed
to reflect how the tiling will be performed. This is not considered
in AMReX.</p>
<p>We have recently introduced logical tiling into parts of AMReXİt
is off by default, to make the transition smooth and because not
everything should be tiled. It can be enabled on a loop-by-loop basis
by setting an optional argument to MFIter. We demonstrate this
below. Further examples can be found at Tutorials/Tiling_C,
and Src/LinearSolvers/C_CellMG/.</p>
<p>In our logical tiling approach, a box is logically split into tiles,
and a MFIter loops over each tile in each box. Note that the
non-tiling iteration approach can be considered as a special case of
tiling with the tile size equal to the box size.</p>
<p>Let us consider an example. Suppose there are four boxes—see
Figure&nbsp;<a class="reference external" href="#fig:domain-tiling">[fig:domain-tiling]</a>.</p>
<div class="figure" id="id11">
<img alt="tiling of the domain" src="_images/domain-tile.png" />
<p class="caption"><span class="caption-text">A simple domain showing 4 Boxes labeled 0–3, and their tiling
regions (dotted lines)</span></p>
</div>
<p>The first box is divided into 4 logical tiles, the second and third
are divided into 2 tiles each (because they are small), and the fourth
into 4 tiles. So there are 12 tiles in total. The difference between
the tiling and non-tiling version are then:</p>
<ul class="simple">
<li>In the tiling version, the loop body will be run 12 times. Note
that tilebox is different for each tile, whereas fab
might be referencing the same object if the tiles belong to the same
box.</li>
<li>In the non-tiling version (by constructing MFIter without
the optional second argument or setting to false), the loop
body will be run 4 times because there are four boxes, and a call to
mfi.tilebox() will return the traditional validbox. The
non-tiling case is essentially having one tile per box.</li>
</ul>
<p>The tiling implementation of the same call to our the Fortran
do_work routine is show below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">tiling</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">tiling</span><span class="p">);</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span> <span class="c1">// Loop over tiles</span>
<span class="p">{</span>
  <span class="c1">// Get the index space of this iteration.</span>
  <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">growntilebox</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="c1">// Get a reference to the FAB, which contains data and box</span>
  <span class="n">FArrayBox</span><span class="o">&amp;</span> <span class="n">fab</span> <span class="o">=</span> <span class="n">mf</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span>

  <span class="c1">// Get the index space for the data pointed by the double*.</span>
  <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">abox</span> <span class="o">=</span> <span class="n">fab</span><span class="p">.</span><span class="n">box</span><span class="p">();</span>

  <span class="c1">// We can now pass the information to a Fortran routine.</span>
  <span class="n">do_work</span><span class="p">(</span><span class="n">ARLIM_3D</span><span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">loVect</span><span class="p">()),</span> <span class="n">ARLIM_3D</span><span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">hiVect</span><span class="p">()),</span>
          <span class="n">fab</span><span class="p">.</span><span class="n">dataPtr</span><span class="p">(),</span> <span class="n">fab</span><span class="p">.</span><span class="n">nComp</span><span class="p">(),</span>
          <span class="n">ARLIM_3D</span><span class="p">(</span><span class="n">abox</span><span class="p">.</span><span class="n">loVect</span><span class="p">()),</span> <span class="n">ARLIM_3D</span><span class="p">(</span><span class="n">abox</span><span class="p">.</span><span class="n">hiVect</span><span class="p">())</span>

<span class="p">}</span>
</pre></div>
</div>
<p>Note that the code is almost identical to the one in §&nbsp;<a class="reference external" href="#sec:boxlib0">[sec:boxlib0]</a>.
Some comments:</p>
<ul>
<li><p class="first">The iterator now takes an extra argument to turn on tiling (set
to true).</p>
<p>There is another interface fo MFIter that can take an
IntVect that explicitly gives the tile size in each coordinate
direction. If we don’t explictly specify the tile size at the loop,
then the runtime parameter fabarray.mfiter_tile_size
can be used to set it globally.</p>
</li>
<li><p class="first">.validBox() has the same meaning as in the non-tile
approach, so we don’t use it.
Since in this example, we want to include a single ghost cell in our
loop over the data, we use .growntilebox(1) (where the 1
here indicates a single ghost cells) to get the Box (and
corresponding lo and hi) for the <em>current tile</em>, not
the entire data region. If instead, we just wanted the valid
region in Fortran, without any ghost cells, we would use
.tilebox().</p>
</li>
<li><p class="first">When passing into the Fortran routine, we still use the index
space of the entire FArrayBox&nbsp;(including ghost cells), as seen in
the abox construction. This is needed to properly dimension
the array in Fortran.</p>
<p>The Fortran routine will declare a multidimensional array that is of
the same size as the entire box, but only work on the index space
identified by the tile-box (box).</p>
</li>
</ul>
<p>The Fortran code is almost the same as before, but now our loop
simply uses lo and hi, since, by construction with
.growntilebox(1), this already includes the single ghost cell
all around:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">do_work</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="p">&amp;</span>
                   <span class="n">state</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="p">&amp;</span>
                   <span class="n">s_lo</span><span class="p">,</span> <span class="n">s_hi</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;do_work&quot;</span><span class="p">)</span>

  <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
  <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">s_lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">s_hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">ncomp</span>

  <span class="kt">real</span> <span class="p">(</span><span class="nb">kind</span><span class="o">=</span><span class="n">dp_t</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">state</span><span class="p">(</span><span class="n">s_lo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">s_hi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="p">&amp;</span>
                                           <span class="n">s_lo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">s_hi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="p">&amp;</span>
                                           <span class="n">s_lo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">s_hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">ncomp</span><span class="p">)</span>

  <span class="c">! loop over the data</span>
  <span class="k">do </span><span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
     <span class="k">do </span><span class="n">j</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

           <span class="c">! work on state(i,j,k,:), where the last index</span>
           <span class="c">! is the component of the multifab</span>

        <span class="n">enddo</span>
     <span class="n">enddo</span>
  <span class="n">enddo</span>

<span class="k">end subroutine </span><span class="n">do_work</span>
</pre></div>
</div>
<p>The function prototype is unchanged.</p>
<p>Tiling provides us the opportunity of a coarse-grained approach for
OpenMP. Threading can be turned on by inserting the following line
above the for (MFIter…) line.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#pragma omp parallel</span>
</pre></div>
</div>
<p>Note that the OpenMP pragma does not have a for—this is not
used when working with an iterator.</p>
<p>Assuming four threads are used in the above example, thread 0 will
work on 3 tiles from the first box, thread 1 on 1 tile from the first
box and 2 tiles from the second box, and so forth. Note that
OpenMP can be used even when tiling is turned off. In that case, the
OpenMP granularity is at the box level (and good performance would need
many boxes per MPI task).</p>
<p>The tile size for the three spatial dimensions can be set by a
parameter, e.g., fabarray.mfiter_tile_size = 1024000 8 8. A
huge number like 1024000 will turn off tiling in that direction.
As noted above, the MFIter constructor can also take an explicit
tile size: MFIter(mfi(mf,IntVect(128,16,32))).</p>
<p>Note that tiling can naturally transition from all threads working
on a single box to each thread working on a separate box as the boxes
coarsen (e.g., in multigrid).</p>
<p>The MFIter class provides some other useful functions:</p>
<ul class="simple">
<li>mfi.validbox() : The same meaning as before independent of tiling.</li>
<li>mfi.tilebox() : The standard way of getting the bounds of the
current tile box. This will tile over the valid data region only.</li>
<li>mfi.growntilebox(int) : A grown tile box that includes
ghost cells at box boundaries only. Thus the returned boxes for a
FArrayBox&nbsp;are non-overlapping.</li>
<li>mfi.nodaltilebox(int) : Returns non-overlapping
edge-type boxes for tiles. The argument is for direction.</li>
<li>mfi.fabbox() : Same as mf[mfi].box().</li>
</ul>
<p>Finally we note that tiling is not always desired or better. The
traditional fine-grained approach coupled with dynamic scheduling is
more appropriate for work with unbalanced loads, such as chemistry
burning in cells by an implicit solver. Tiling can also create extra
work in the ghost cells of tiles.</p>
<div class="section" id="practical-details-in-working-with-tiling">
<h4>Practical Details in Working with Tiling<a class="headerlink" href="#practical-details-in-working-with-tiling" title="Permalink to this headline">¶</a></h4>
<p>With tiling, the OpenMP is now all in C, and not in Fortran for all
modules except reactions and initdata.</p>
<p>It is the responsibility of the coder to make sure that the routines
within a tiled region are safe to use with OpenMP. In particular,
note that:</p>
<ul>
<li><p class="first">tile boxes are non-overlapping</p>
</li>
<li><p class="first">the union of tile boxes completely cover the valid region of the
fab</p>
</li>
<li><p class="first">Consider working with a node-centered MultiFab, ugdnv, and
a cell-centered MultiFab, s:</p>
<ul class="simple">
<li>with mfi(s), the tiles are based on the cell-centered
index space. If you have an <span class="math notranslate nohighlight">\(8\times 8\)</span> box, then and 4 tiles,
then your tiling boxes will range from <span class="math notranslate nohighlight">\(0\rightarrow 3\)</span>,
<span class="math notranslate nohighlight">\(4\rightarrow 7\)</span>.</li>
<li>with mfiugdnv, the tiles are based on nodal indices,
so your tiling boxes will range from <span class="math notranslate nohighlight">\(0\rightarrow 3\)</span>,
<span class="math notranslate nohighlight">\(4\rightarrow 8\)</span>.</li>
</ul>
</li>
<li><p class="first">When updating routines to work with tiling, we need to
understand the distinction between the index-space of the entire box
(which corresponds to the memory layout) and the index-space of the
tile.</p>
<ul>
<li><p class="first">In the C&nbsp;end, we pass (sometimes via the
BL_TO_FORTRAN() macro) the loVect and hiVect of the
entire box (including ghost cells). These are then used to
allocate the array in Fortran as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">double</span> <span class="n">precision</span> <span class="p">::</span> <span class="n">a</span><span class="p">(</span><span class="n">a_l1</span><span class="p">:</span><span class="n">a_h1</span><span class="p">,</span> <span class="n">a_l2</span><span class="p">:</span><span class="n">a_h2</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>When tiling is used, we do not want to loop as do a_l1,
a_h1, but instead we need to loop over the tiling region. The
indices of the tiling region need to be passed into the Fortran
routine separately, and they come from the mfi.tilebox()
or mfi.growntilebox() statement.</p>
</li>
<li><p class="first">In Fortran, when initializing an array to 0, do so only
over the tile region, not for the entire box. For a Fortran array
a, this means we cannot do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">a</span><span class="p">(:,:,:,:)</span> <span class="o">=</span> <span class="mf">0.0</span>
</pre></div>
</div>
<p>but instead must do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">(</span><span class="n">lo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">hi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">lo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">hi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),:)</span> <span class="o">=</span> <span class="mf">0.0</span>
</pre></div>
</div>
<p>where lo() and hi() are the index-space for the tile box
returned from mfi.tilebox() in C&nbsp;and passed into the Fortran
routine.</p>
</li>
<li><p class="first">Look at r_old_s in Exec/gravity_tests/DustCollapse/probdata.f90 as an
example of how to declare a threadprivate variable—this is then used
in sponge_nd.f90.</p>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="section" id="boundaries-fillpatch-and-fillpatchiterator">
<h2>Boundaries: FillPatch and FillPatchIterator<a class="headerlink" href="#boundaries-fillpatch-and-fillpatchiterator" title="Permalink to this headline">¶</a></h2>
<p>AMReX&nbsp;calls the act of filling ghost cells a <em>fillpatch</em>
operation. Boundaries between grids are of two types. The first we
call “fine-fine”, which is two grids at the same level. The second
type is “coarse-fine”, which needs interpolation from the coarse grid
to fill the fine grid ghost cells. Both of these are part of the
fillpatch operation. Fine-fine fills are just a straight copy from
“valid regions” to ghost cells. Coarse-fine fills are enabled
because the StateData&nbsp;is not just arrays, they’re “State Data”,
which means that the data knows how to interpolate itself (in an
anthropomorphical sense). The type of interpolation to use is defined
in Castro_setup.cpp—search for
cell_cons_interp, for example—that’s “cell conservative
interpolation”, i.e., the data is cell-based (as opposed to
node-based or edge-based) and the interpolation is such that the
average of the fine values created is equal to the coarse value from
which they came. (This wouldn’t be the case with straight linear
interpolation, for example.)</p>
<p>Additionally, since StateData&nbsp;has an old and new timelevel,
the fill patch operation can interpolate to an intermediate time.</p>
<div class="section" id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<p>To illustrate the various ways we fill ghost cells and use the data,
let’s consider the following scenarios:</p>
<ul>
<li><p class="first"><em>You have state data that was defined with no ghost cells. You
want to create a new MultiFab&nbsp;containing a copy of that data with
NGROW ghost cells.</em></p>
<p>This is the case with Sborder—the MultiFab&nbsp;of the
hydrodynamic state that we use to kick-off the hydrodynamics
advance.</p>
<p>Sborder is declared in Castro.H simply as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Multifab</span> <span class="n">Sborder</span><span class="p">;</span>
</pre></div>
</div>
<p>It is then allocated in Castro::initialize_do_advance()</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Sborder</span><span class="p">.</span><span class="n">define</span><span class="p">(</span><span class="n">grids</span><span class="p">,</span> <span class="n">NUM_STATE</span><span class="p">,</span> <span class="n">NUM_GROW</span><span class="p">,</span> <span class="n">Fab_allocate</span><span class="p">);</span>
<span class="k">const</span> <span class="n">Real</span> <span class="n">prev_time</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">State_Type</span><span class="p">].</span><span class="n">prevTime</span><span class="p">();</span>
<span class="n">expand_state</span><span class="p">(</span><span class="n">Sborder</span><span class="p">,</span> <span class="n">prev_time</span><span class="p">,</span> <span class="n">NUM_GROW</span><span class="p">);</span>
</pre></div>
</div>
<p>Note in the call to .define(), we tell AMReX&nbsp;to already
allocate the data regions for the FArrayBoxs that are part of
Sborder.</p>
<p>The actually filling of the ghost cells is done by
Castro::expand_state():</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">AmrLevel</span><span class="o">::</span><span class="n">FillPatch</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">Sborder</span><span class="p">,</span> <span class="n">NUM_GROW</span><span class="p">,</span>
                    <span class="n">prev_time</span><span class="p">,</span> <span class="n">State_Type</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NUM_STATE</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, we are filling the ng ghost cells of MultiFab
Sborder at time prev_time. We are using the
StateData&nbsp;that is part of the current Castro object that we
are part of. Note: FillPatch takes an object reference as its
first argument, which is the object that contains the relevant
StateData—that is what the this pointer indicates.
Finally, we are copying the State_Type data components 0 to
NUM_STATE <a class="footnote-reference" href="#id8" id="id3">[3]</a>.</p>
<p>The result of this operation is that Sborder will now have
NUM_GROW ghost cells consistent with the State_Type
data at the old time-level.</p>
</li>
<li><p class="first"><em>You have state data that was defined with NGROW ghost
cells. You want to ensure that the ghost cells are filled
(including any physical boundaries) with valid data.</em></p>
<p>This is very similar to the procedure shown above. The main
difference is that for the MultiFab&nbsp;that will be the target
of the ghost cell filling, we pass in a reference to the StateData&nbsp;itself.</p>
<p>The main thing you need to be careful of here, is that you
need to ensure that the the time you are at is consistent with
the StateData’s time. Here’s an example from the radiation
portion of the code MGFLDRadSolver.cpp:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Real</span> <span class="n">time</span> <span class="o">=</span> <span class="n">castro</span><span class="o">-&gt;</span><span class="n">get_state_data</span><span class="p">(</span><span class="n">Rad_Type</span><span class="p">).</span><span class="n">curTime</span><span class="p">();</span>
<span class="n">MultiFab</span><span class="o">&amp;</span> <span class="n">S_new</span> <span class="o">=</span> <span class="n">castro</span><span class="o">-&gt;</span><span class="n">get_new_data</span><span class="p">(</span><span class="n">State_Type</span><span class="p">);</span>

<span class="n">AmrLevel</span><span class="o">::</span><span class="n">FillPatch</span><span class="p">(</span><span class="o">*</span><span class="n">castro</span><span class="p">,</span> <span class="n">S_new</span><span class="p">,</span> <span class="n">ngrow</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">State_Type</span><span class="p">,</span>
                    <span class="mi">0</span><span class="p">,</span> <span class="n">S_new</span><span class="p">.</span><span class="n">nComp</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>In this example, S_new is a pointer to the new-time-level
State_Type MultiFab. So this operation will use the
State_Type data to fill its own ghost cells. we fill the
ngrow ghost cells of the new-time-level State_Type data,
for all the components.</p>
<p>Note that in this example, because the StateData&nbsp;lives in the
Castro object and we are working from the Radiation object,
we need to make reference to the current castro object
pointer. If this were all done within the Castro object, then
the pointer will simply be this, as we saw above.</p>
</li>
<li><p class="first"><em>You have a MultiFab&nbsp;with some derived quantity. You want to
fill its ghost cells.</em></p>
<p>MultiFabs have a FillBoundary() method that will fill all
the ghost cells between boxes at the same level. It will not fill
ghost cells at coarse-fine boundaries or at physical boundaries.</p>
</li>
<li><p class="first"><em>You want to loop over the FABs in state data, filling ghost cells
along the way</em></p>
<p>This is the job of the —this iterator is used to
loop over the grids and fill ghostcells. A key thing to keep in
mind about the FillPatchIterator&nbsp;is that you operate on a copy
of the data—the data is disconnected from the original source. If
you want to update the data in the source, you need to explicitly
copy it back. Also note: FillPatchIterator takes a multifab,
but this is not filled—this is only used to get the grid
layout. Finally, the way the FillPatchIterator&nbsp;is implemented
is that all the communication is done first, and then the iterating
over boxes commences.</p>
<p>For example, the loop that calls CA_UMDRV (all the
hydrodynamics integration stuff) starts with</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">FillPatchIterator</span> <span class="n">fpi</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="n">S_new</span><span class="p">,</span> <span class="n">NUM_GROW</span><span class="p">,</span>
                           <span class="n">time</span><span class="p">,</span> <span class="n">State_Type</span><span class="p">,</span> <span class="n">strtComp</span><span class="p">,</span> <span class="n">NUM_STATE</span><span class="p">);</span>
      <span class="n">fpi</span><span class="o">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">fpi</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">FArrayBox</span> <span class="o">&amp;</span><span class="n">state</span> <span class="o">=</span> <span class="n">fpi</span><span class="p">();</span>
  <span class="n">Box</span> <span class="n">bx</span><span class="p">(</span><span class="n">fpi</span><span class="o">.</span><span class="n">validbox</span><span class="p">());</span>

  <span class="o">//</span> <span class="n">work</span> <span class="n">on</span> <span class="n">the</span> <span class="n">state</span> <span class="n">FAB</span><span class="o">.</span>  <span class="n">The</span> <span class="n">interior</span> <span class="p">(</span><span class="n">valid</span><span class="p">)</span> <span class="n">cells</span> <span class="n">will</span>
  <span class="o">//</span> <span class="n">live</span> <span class="n">between</span> <span class="n">bx</span><span class="o">.</span><span class="n">loVect</span><span class="p">()</span> <span class="ow">and</span> <span class="n">bx</span><span class="o">.</span><span class="n">hiVect</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here the FillPatchIterator is the thing that distributes the
grids over processors and makes parallel “just work”. This fills the
single patch “fpi” , which has NUM_GROW ghost cells,
with data of type “State_Type” at time “time”,
starting with component strtComp and including a total of
NUM_STATE components.</p>
</li>
</ul>
<p>In general, one should never assume that ghostcells are valid, and
instead do a fill patch operation when in doubt. Sometimes we will
use a FillPatchIterator&nbsp;to fill the ghost cells into a multifab
without an explict look. This is done as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FillPatchIterator</span> <span class="n">fpi</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">,</span><span class="n">S_old</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">time</span><span class="p">,</span><span class="n">State_Type</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">NUM_STATE</span><span class="p">);</span>
<span class="n">MultiFab</span><span class="o">&amp;</span> <span class="n">state_old</span> <span class="o">=</span> <span class="n">fpi</span><span class="o">.</span><span class="n">get_mf</span><span class="p">();</span>
</pre></div>
</div>
<p>In this operation, state_old points to the internal
MultiFab&nbsp;in the FillPatchIterator, by getting a reference to it as
fpi.get_mf(). This avoids a local copy.</p>
<p>Note that in the examples above, we see that only StateData&nbsp;can fill
physical boundaries (because these register how to fill the boundaries
when they are defined). There are some advanced operations in
AMReX&nbsp;that can get around this, but we do not use them in Castro.</p>
</div>
<div class="section" id="physical-boundaries">
<span id="soft-phys-bcs"></span><h3>Physical Boundaries<a class="headerlink" href="#physical-boundaries" title="Permalink to this headline">¶</a></h3>
<p>Physical boundary conditions are specified by an integer
index <a class="footnote-reference" href="#id9" id="id4">[4]</a> in
the inputs file, using the castro.lo_bc and
castro.hi_bc runtime parameters. The generally
supported boundary conditions are, their corresponding integer key,
and the action they take for the normal velocity, transverse
velocity, and generic scalar are shown in Table&nbsp;<a class="reference external" href="#table:castro:bcs">[table:castro:bcs]</a></p>
<p>The definition of the specific actions are:</p>
<ul class="simple">
<li>INT_DIR: data taken from other grids or interpolated</li>
<li>EXT_DIR: data specified on EDGE (FACE) of bndry</li>
<li>HOEXTRAP: higher order extrapolation to EDGE of bndry</li>
<li>FOEXTRAP: first order extrapolation from last cell in interior</li>
<li>REFLECT_EVEN: <span class="math notranslate nohighlight">\(F(-n) = F(n)\)</span> true reflection from interior cells</li>
<li>REFLECT_ODD: <span class="math notranslate nohighlight">\(F(-n) = -F(n)\)</span> true reflection from interior cells</li>
</ul>
<p>The actual registration of a boundary condition action to a particular
variable is done in Castro_setup.cpp. At the top we define
arrays such as “scalar_bc”, “norm_vel_bc”, etc,
which say which kind of bc to use on which kind of physical boundary.
Boundary conditions are set in functions like “
set_scalar_bc”, which uses the scalar_bc pre-defined
arrays. We also specify the name of the Fortran routine that
is responsible for filling the data there (e.g., hypfill).
These routines are discussed more below.</p>
<p>If you want to specify a value at a function (like at an inflow
boundary), then you choose an <em>inflow</em> boundary at that face of
the domain. You then need to write the implementation code for this.
An example is the problem toy_convect which implements a
hydrostatic lower boundary (through its custom <a href="#id13"><span class="problematic" id="id14">bc_fill_</span></a>?d.F90
routines.</p>
<table border="1" class="docutils" id="id12">
<caption><span class="caption-text">[table:castro:bcs] Physical boundary conditions supported in Castro. why does slipwall and noslipwall do the same thing?</span><a class="headerlink" href="#id12" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>name</strong></th>
<th class="head"><strong>integer</strong></th>
<th class="head"><strong>normal
velocity</strong></th>
<th class="head"><strong>transvers
e
velocity</strong></th>
<th class="head"><strong>scalars</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>interior</td>
<td>0</td>
<td>INT_DIR</td>
<td>INT_DIR</td>
<td>INT_DIR</td>
</tr>
<tr class="row-odd"><td>inflow</td>
<td>1</td>
<td>EXT_DIR</td>
<td>EXT_DIR</td>
<td>EXT_DIR</td>
</tr>
<tr class="row-even"><td>outflow</td>
<td>2</td>
<td>FOEXTRAP</td>
<td>FOEXTRAP</td>
<td>FOEXTRAP</td>
</tr>
<tr class="row-odd"><td>symmetry</td>
<td>3</td>
<td>REFLECT_ODD</td>
<td>REFLECT_EVE
N</td>
<td>REFLECT_EVE
N</td>
</tr>
<tr class="row-even"><td>slipwall</td>
<td>4</td>
<td>REFLECT_ODD</td>
<td>REFLECT_EVE
N</td>
<td>REFLECT_EVE
N</td>
</tr>
<tr class="row-odd"><td>noslipwall</td>
<td>5</td>
<td>REFLECT_ODD</td>
<td>REFLECT_EVE
N</td>
<td>REFLECT_EVE
N</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="fluxregister">
<h3>FluxRegister<a class="headerlink" href="#fluxregister" title="Permalink to this headline">¶</a></h3>
<p>A FluxRegister&nbsp;holds face-centered data at the boundaries of a box.
It is composed of a set of MultiFabs (one for each face, so 6 for
3D). A FluxRegister&nbsp;stores fluxes at coarse-fine interfaces,
and isused for the flux-correction step.</p>
</div>
</div>
<div class="section" id="other-amrex-concepts">
<h2>Other AMReX&nbsp;Concepts<a class="headerlink" href="#other-amrex-concepts" title="Permalink to this headline">¶</a></h2>
<p>There are a large number of classes that help define the structure of
the grids, metadata associate with the variables, etc. A good way to
get a sense of these is to look at the .H files in the
amrex/Src/ directory.</p>
<div class="section" id="geometry-class">
<h3>Geometry class<a class="headerlink" href="#geometry-class" title="Permalink to this headline">¶</a></h3>
<p>There is a Geometry object, geom for each level as part of
the Castro object (this is inhereted through AmrLevel).</p>
</div>
<div class="section" id="parmparse-class">
<h3>ParmParse class<a class="headerlink" href="#parmparse-class" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="error-estimators">
<h3>Error Estimators<a class="headerlink" href="#error-estimators" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="gravity-class">
<h2>Gravity class<a class="headerlink" href="#gravity-class" title="Permalink to this headline">¶</a></h2>
<p>There is a single Gravity object, gravity, that is a
static class member of the Castro object. This means that all
levels refer to the same Gravity object.</p>
<p>Within the Gravity object, there are pointers to the Amr
object (as parent), and all of the AmrLevels (as a PArray,
LevelData). The gravity object gets the geometry
information at each level through the parent Amr class.</p>
<p>The main job of the gravity object is to provide the potential
and gravitation acceleration for use in the hydrodynamic sources.
Depending on the approximation used for gravity, this could mean
calling the AMReX&nbsp;multigrid solvers to solve the Poisson equation.</p>
</div>
<div class="section" id="fortran-helper-modules">
<h2>Fortran Helper Modules<a class="headerlink" href="#fortran-helper-modules" title="Permalink to this headline">¶</a></h2>
<p>There are a number of modules that make data available to the Fortran
side of Castro&nbsp;or perform other useful tasks.</p>
<ul>
<li><p class="first">bl_constants_module:</p>
<p>This provides double precision constants as Fortran parameters, like
ZERO, HALF, and ONE.</p>
</li>
<li><p class="first">bl_types:</p>
<p>This provides a double precision type, dp_t for use in
Fortran. This should be identical to double precision on most
architectures.</p>
</li>
<li><p class="first">extern_probin_module:</p>
<p>This module provides access to the runtime parameters for the
microphysics routines (EOS, reaction network, etc.). The source
for this module is generated at compile type via a make rule
that invokes a python script. This will search for all of the
_parameters files in the external sources, parse them
for runtime parameters, and build the module.</p>
</li>
<li><p class="first">fundamental_constants_module:</p>
<p>This provides the CGS values of many physical constants.</p>
</li>
<li><p class="first">math_module:</p>
<p>This provides simple mathematical functions. At the moment, a cross
product routine.</p>
</li>
<li><p class="first">meth_params_module:</p>
<p>This module provides the integer keys used to access the state
arrays for both the conserved variables (URHO, UMX, <span class="math notranslate nohighlight">\(\ldots\)</span>)
and primitive variables (QRHO, QU, <span class="math notranslate nohighlight">\(\ldots\)</span>), as well
as the number of scalar variables.</p>
<p>It also provides the values of most of the castro.<em>xxxx</em>
runtime parameters.</p>
</li>
<li><p class="first">model_parser_module:</p>
<p>This module is built if USE_MODELPARSER = TRUE is set in the
problem’s GNUmakefile. It then provides storage for the an
initial model and routines to read it in and interpolate onto the
Castro&nbsp;grid.</p>
</li>
<li><p class="first">prob_params_module:</p>
<p>[soft:prob_params]</p>
<p>This module stores information about the domain and current level,
and is periodically synced up with the C&nbsp;driver. The information
available here is:</p>
<ul>
<li><p class="first">physbc_lo, physbc_hi: these are the boundary
condition types at the low and high ends of the domain, for each
coordinate direction. Integer keys, Interior, Inflow,
Outflow, Symmetry, SlipWall, and
NoSlipWall allow you to interpret the values.</p>
</li>
<li><p class="first">center is the center of the problem. Note—this is up
to the problem setup to define (in the probinit subroutine).
Alternately, it can be set at runtime via
castro.center.</p>
<p>Usually center will be the physical center of the domain,
but not always. For instance, for axisymmetric problems,
center may be on the symmetry axis.</p>
<p>center is used in the multipole gravity, hybrid advection
algorithm, rotation sources, for the point mass gravity, in
defining the center of the sponge, and in deriving the radial
velocity.</p>
</li>
<li><p class="first">coord_type</p>
</li>
<li><p class="first">dim</p>
</li>
<li><p class="first">dg</p>
</li>
<li><p class="first"><em>refining information</em></p>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="setting-up-your-own-problem">
<h2>Setting Up Your Own Problem<a class="headerlink" href="#setting-up-your-own-problem" title="Permalink to this headline">¶</a></h2>
<p>To define a new problem, we create a new directory in one
of the subdirectories of Exec/,
and place in it a Prob_2d.f90 file (or 1d/3d,
depending on the dimensionality of the problem), a probdata.f90
file, the inputs and probin files, and a
Make.package file that tells the build system what problem-specific
routines exist. Finally, if you need custom boundary conditions, a
bc_fill_2d.F90 (or 1d/3d) file is needed. The
simplest way to get started is to copy these files from an existing
problem. Here we describe how to customize your problem.</p>
<p>The purpose of these files is:</p>
<ul>
<li><p class="first">probdata.f90: this holds the probdata_module Fortran module
that allocates storage for all the problem-specific runtime parameters that
are used by the problem (including those that are read from the probin
file.</p>
</li>
<li><p class="first"><a href="#id15"><span class="problematic" id="id16">Prob_</span></a>?d.f90: this holds the main routines to
initialize the problem and grid and perform problem-specific boundary
conditions:</p>
<ul>
<li><p class="first">probinit():</p>
<p>This routine is primarily responsible for reading in the
probin file (by defining the &amp;fortin namelist and
reading in an initial model (usually through the
model_parser_module—see the toy_convect problem
setup for an example). The parameters that are initialized
here are those stored in the probdata_module.</p>
</li>
<li><p class="first">ca_initdata():</p>
<p>This routine will initialize the state data for a single grid.
The inputs to this routine are:</p>
<ul>
<li><p class="first">level: the level of refinement of the grid we are filling</p>
</li>
<li><p class="first">time: the simulation time</p>
</li>
<li><p class="first">lo(), hi(): the integer indices of the box’s
<em>valid data region</em> lower left and upper right corners. These
integers refer to a global index space for the level and
identify where in the computational domain the box lives.</p>
</li>
<li><p class="first">nscal: the number of scalar quantities—this is not typically
used in Castro.</p>
</li>
<li><p class="first">state_l1, state_l2, (state_l3): the
integer indices of the lower left corner of the box in each
coordinate direction. These are for the box as allocated in memory,
so they include any ghost cells as well as the valid data regions.</p>
</li>
<li><p class="first">state_h1, state_h2, (state_h3): the
integer indices of the upper right corner of the box in each
coordinate direction. These are for the box as allocated in memory,
so they include any ghost cells as well as the valid data regions.</p>
</li>
<li><p class="first">state(): the main state array. This is dimensioned as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">double</span> <span class="n">precision</span> <span class="n">state</span><span class="p">(</span><span class="n">state_l1</span><span class="p">:</span><span class="n">state_h1</span><span class="p">,</span><span class="n">state_l2</span><span class="p">:</span><span class="n">state_h2</span><span class="p">,</span><span class="n">NVAR</span><span class="p">)</span>
</pre></div>
</div>
<p>(in 2-d), where NVAR comes from the meth_params_module.</p>
<p>When accessing this array, we use the index keys provided by
meth_params_module (e.g., URHO) to refer to specific
quantities</p>
</li>
<li><p class="first">delta(): this is an array containing the zone width (<span class="math notranslate nohighlight">\(\Delta x\)</span>)
in each coordinate direction: <span class="math notranslate nohighlight">\(\mathtt{delta(1)} = \Delta x\)</span>,
<span class="math notranslate nohighlight">\(\mathtt{delta(2)} = \Delta y\)</span>, <span class="math notranslate nohighlight">\(\ldots\)</span>.</p>
</li>
<li><p class="first">xlo(), xhi(): these are the physical coordinates of the
lower left and upper right corners of the <em>valid region</em>
of the box. These can be used to compute the coordinates of the
cell-centers of a zone as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">do</span> <span class="n">j</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
   <span class="n">y</span> <span class="o">=</span> <span class="n">xlo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">delta</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">dble</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">lo</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.5</span><span class="n">d0</span><span class="p">)</span>
   <span class="o">...</span>
</pre></div>
</div>
<p>(Note: this method works fine for the problem initialization
stuff, but for routines that implement tiling, as discussed below,
lo and xlo may not refer to the same corner, and instead
coordinates should be computed using problo() from the
prob_params_module.)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p class="first"><a href="#id17"><span class="problematic" id="id18">bc_fill_</span></a>?d.F90:</p>
<p>These routines handle how Castro&nbsp;fills ghostcells
<em>at physical boundaries</em> for specific data. Most problem
setups won’t need to do anything special here, and inclusion
of this file is optional – only use it if you need to set
specific boundary conditions.</p>
<p>These routines are registered in Castro_setup.cpp, and
called as needed. By default, they just
pass the arguments through to filcc, which handles all of
the generic boundary conditions (like reflecting, extrapolation,
etc.). The specific ‘fill’ routines can then supply the
problem-specific boundary conditions, which are typically just
Dirichlet boundary conditions (usually this means looking to see
if the bc() flag at a boundary is EXT_DIR. The
problem-specific code implementing these specific conditions
should <em>follow</em> the filcc call.</p>
<ul>
<li><p class="first">ca_hypfill:
This handles the boundary filling for the hyperbolic system.</p>
</li>
<li><p class="first">ca_denfill: At times, we need to fill just the density
(always assumed to be the first element in the hyperbolic state)
instead of the entire state. When the fill patch routine is called
with first_comp = Density and num_comp = 1, then we
use ca_denfill instead of ca_hypfill.</p>
<p>(Note: it seems that this may be used for more than just
density, but it is only used for tagging and the plotfile)</p>
</li>
<li><p class="first">ca_grav?fill: These routines fill will the ghostcells
of the gravitational acceleration grids with the gravitational
acceleration.</p>
<p>Note: for constant gravity, these routines will never be called.
For one of the Poisson-type gravities, you only need to do
something special here if you are implementing an Interior
boundary type (which you can test for by comparing
bc(:,:,:) to EXT_DIR.</p>
<p>For the other standard physical boundary types, the ghost cell
filling will be handled automatically by the default filcc
call in these routines.</p>
<p>The gravitational acceleration in the ghost cells is used during
the hydrodynamics portion of the code in predicting the
interface states.</p>
</li>
<li><p class="first">ca_reactfill: This handles boundary filling for
any Reactions_Type MultiFABs, which are sometimes used to interface
with the nuclear burning module. It stores the normal state data
in addition to components for the energy release and species change.</p>
</li>
</ul>
<p>These routines take the following arguments:</p>
<ul>
<li><p class="first">adv_l1, adv_l2, (adv_l3): the indicies of
the lower left corner of the box holding the data we are working on.
These indices refer to the entire box, including ghost cells.</p>
</li>
<li><p class="first">adv_h1, adv_h2, (adv_h3): the indicies of
the upper right corner of the box holding the data we are working on.
These indices refer to the entire box, including ghost cells.</p>
</li>
<li><p class="first">adv(): the array of data whose ghost cells we are filling.
Depending on the routine, this may have an additional index refering
to the variable.</p>
<p>This is dimensioned as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">double</span> <span class="n">precision</span> <span class="n">adv</span><span class="p">(</span><span class="n">adv_l1</span><span class="p">:</span><span class="n">adv_h1</span><span class="p">,</span><span class="n">adv_l2</span><span class="p">:</span><span class="n">adv_h2</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">domlo(), domhi(): the integer indices of the lower
left and upper right corners of the valid region of the <em>entire
domain</em>. These are used to test against to see if we are filling
physical boundary ghost cells.</p>
<p>This changes according to refinement level: level-0 will
range from 0 to castro.max_grid_size,
and level-n will range from 0 to
<span class="math notranslate nohighlight">\(\mathtt{castro.max\_grid\_size} \cdot \prod_n \mathtt{castro.ref\_ratio(n)}\)</span>.</p>
</li>
<li><p class="first">delta(): is the zone width in each coordinate direction,
as in initdata() above.</p>
</li>
<li><p class="first">xlo(): this is the physical coordinate of the lower
left corner of the box we are filling—including the ghost cells.</p>
<p>Note: this is different than how xlo() was defined in
initdata() above.</p>
</li>
<li><p class="first">time: the simulation time</p>
</li>
<li><p class="first">bc(): an array that holds the type of boundary conditions
to enforce at the physical boundaries for adv.</p>
<p>Sometimes it appears of the form bc(:,:) and sometimes
bc(:,:,:)—the last index of the latter holds the variable
index, i.e., density, pressure, species, etc.</p>
<p>The first index is the coordinate direction and the second index
is the domain face (1 is low, 2 is hi), so
bc(1,1) is the lower <span class="math notranslate nohighlight">\(x\)</span> boundary type, bc(1,2) is
the upper <span class="math notranslate nohighlight">\(x\)</span> boundary type, bc(2,1) is the lower
<span class="math notranslate nohighlight">\(y\)</span> boundary type, etc.</p>
<p>To interpret the array values, we test against the quantities
defined in bc_types.fi included in each subroutine,
for example, EXT_DIR, FOEXTRAP, <span class="math notranslate nohighlight">\(\ldots\)</span>. The
meaning of these are explained below.</p>
</li>
</ul>
</li>
</ul>
<div class="section" id="optional-files">
<h3>Optional Files<a class="headerlink" href="#optional-files" title="Permalink to this headline">¶</a></h3>
<p>The follow problem-specific files are optional. There are stubs for
each of these in the main source tree.</p>
<ul>
<li><p class="first">Problem.f90 :</p>
<p>This provides two routines, problem_checkpoint and
problem_restart that can be used to add information to the
checkpoint files and read it in upon restart. This is useful for
some global problem-specific quantities. For instance, the
wdmerger <a class="footnote-reference" href="#id10" id="id5">[5]</a> problem uses this
to store center of mass position and velocity information in the
checkpoint files that are used for runtime diagnostics.</p>
<p>The name of the checkpoint directory is passed in as an argument.
Problem_F.H provides the C&nbsp;interfaces for these routines.</p>
</li>
<li><p class="first"><a href="#id19"><span class="problematic" id="id20">problem_tagging_</span></a>?d.F90, problem_tagging_nd.F90</p>
<p>This implements problem-specific tagging for refinement, through a
subroutine set_problem_tags. The full hydrodynamic state
(State_Type) is passed in, and the problem can mark zones for
refinement by setting the tag variable for a zone to
set. An example is provided by the toy_convect
problem which refines a rectangular region (fuel layer) based on
a density parameter and the H mass fraction.</p>
</li>
<li><p class="first">Problem_Derive_F.H, Problem_Derives.H, problem_derive_nd.f90</p>
<p>Together, these provide a mechanism to create derived quantities
that can be stored in the plotfile. Problem_Derives.H
provides the C&nbsp;code that defines these new plot variables. It
does this by adding them to the derive_lst—a list of
derived variables that Castro&nbsp;knows about. When adding new
variables, a descriptive name, Fortran routine that does the
deriving, and component of StateData&nbsp;are specified.</p>
<p>The Fortran routine that does the deriving is put in the
problem-specific problem_derive_nd.f90 (and a prototype for
C&nbsp;is put in Problem_Derives.H). A example is provided by
the reacting_bubble problem, which derives several new
quantities (perturbations against a background one-dimensional
model, in this case).</p>
</li>
<li><p class="first">Prob.cpp, Problem.H, Problem_F.H</p>
<p>These files provide problem-specific routines for computing global
diagnostic information through the sum_integrated_quantities
functionality that is part of the Castro class.</p>
<p>An example is provided by toy_flame, where an estimate
of the flame speed is computed by integrating the mass of fuel on
the grid.</p>
</li>
</ul>
</div>
<div class="section" id="dimension-agnostic-problem-initialization">
<h3>Dimension Agnostic Problem Initialization<a class="headerlink" href="#dimension-agnostic-problem-initialization" title="Permalink to this headline">¶</a></h3>
<p>Most of the problem setups have separate implementations for 1-, 2-,
and 3D. A new method exists that allows you to write just a single
set of files for any dimensionality (this is called the <em>dimension
agnostic</em> format). To use this mode, set
DIMENSION_AGNOSTIC= TRUE in your GNUmakefile.
Then write you problem initialization in Prob_nd.F90.
Analogous routines exist for tagging and boundary conditions. See the
rotating_torus and Noh problem setups for an
example.</p>
</div>
</div>
<div class="section" id="parallel-i-o">
<span id="software-io"></span><h2>Parallel I/O<a class="headerlink" href="#parallel-i-o" title="Permalink to this headline">¶</a></h2>
<p>Both checkpoint files and plotfiles are really directories containing
subdirectories: one subdirectory for each level of the AMR hierarchy.
The fundamental data structure we read/write to disk is a MultiFab,
which is made up of multiple FAB’s, one FAB per grid. Multiple
MultiFabs may be written to each directory in a checkpoint file.
MultiFabs of course are shared across CPUs; a single MultiFab may be
shared across thousands of CPUs. Each CPU writes the part of the
MultiFab that it owns to disk, but they don’t each write to their own
distinct file. Instead each MultiFab is written to a runtime
configurable number of files N (N can be set in the inputs file as the
parameter amr.checkpoint_nfiles and amr.plot_nfiles; the
default is 64). That is to say, each MultiFab is written to disk
across at most N files, plus a small amount of data that gets written
to a header file describing how the file is laid out in those N files.</p>
<p>What happens is <span class="math notranslate nohighlight">\(N\)</span> CPUs each opens a unique one of the <span class="math notranslate nohighlight">\(N\)</span> files into
which the MultiFab is being written, seeks to the end, and writes
their data. The other CPUs are waiting at a barrier for those <span class="math notranslate nohighlight">\(N\)</span>
writing CPUs to finish. This repeats for another <span class="math notranslate nohighlight">\(N\)</span> CPUs until all the
data in the MultiFab is written to disk. All CPUs then pass some data
to CPU 0 which writes a header file describing how the MultiFab is
laid out on disk.</p>
<p>We also read MultiFabs from disk in a “chunky” manner, opening only <span class="math notranslate nohighlight">\(N\)</span>
files for reading at a time. The number <span class="math notranslate nohighlight">\(N\)</span>, when the MultiFabs were
written, does not have to match the number <span class="math notranslate nohighlight">\(N\)</span> when the MultiFabs are
being read from disk. Nor does the number of CPUs running while
reading in the MultiFab need to match the number of CPUs running when
the MultiFab was written to disk.</p>
<p>Think of the number <span class="math notranslate nohighlight">\(N\)</span> as the number of independent I/O pathways in
your underlying parallel filesystem. Of course a “real” parallel
filesytem should be able to handle any reasonable value of <span class="math notranslate nohighlight">\(N\)</span>. The
value -1 forces <span class="math notranslate nohighlight">\(N\)</span> to the number of CPUs on which you’re
running, which means that each CPU writes to a unique file, which can
create a very large number of files, which can lead to inode issues.</p>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Note: some older code will use a special AMReX&nbsp;preprocessor macro,
BL_TO_FORTRAN, defined in ArrayLim.H, that converts
the C&nbsp;multifab into a Fortran array and its lo and hi indices.
Additionally, some older code will wrap the Fortran subroutine name
in an additional preprocessor macro, BL_FORT_PROC_CALL
to handle the name mangling between Fortran and C. This later
macro is generally not needed any more because of Fortran 2003
interoperability with C (through the Fortran bind keyword).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>the way to read these complicated
C&nbsp;declarations is right-to-left. So ‘const int* lo‘ means
‘lo‘ is a integer pointer to a memory space that is constant. See
<a class="reference external" href="https://isocpp.org/wiki/faq/const-correctness#ptr-to-const">https://isocpp.org/wiki/faq/const-correctness#ptr-to-const</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>for clarity and continuity in this
documentation, some of the variable names have been changed
compared to the actual code</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>the integer values are defined in BC_TYPES.H</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>available separately at
<a class="reference external" href="https://github.com/BoxLib-Codes/wdmerger">https://github.com/BoxLib-Codes/wdmerger</a></td></tr>
</tbody>
</table>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="faq.html" class="btn btn-neutral float-right" title="Frequently Asked Questions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="FlowChart.html" class="btn btn-neutral" title="Flowchart" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Castro development tem

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"kth": "{{k_\\mathrm{th}}}", "gcc": "{\\mathrm{g~cm^{-3}}}", "cms": "{\\mathrm{cm~s^{-1}}}", "presunit": "{\\mathrm{dyn~cm^{-2}}}", "accelunit": "{\\mathrm{cm~s^{-2}}}", "ergg": "{\\mathrm{erg~g^{-1}}}", "Ab": "{{\\bf A}}", "eb": "{{\\bf e}}", "Fb": "{{\\bf F}}", "gb": "{{\\bf g}}", "Hb": "{{\\bf H}}", "ib": "{{\\bf i}}", "Ib": "{{\\bf I}}", "Kb": "{{\\bf K}}", "lb": "{{\\bf l}}", "Lb": "{{\\bf L}}", "nb": "{{\\bf n}}", "Pb": "{{\\bf P}}", "Qb": "{{\\bf Q}}", "rb": "{{\\bf r}}", "Rb": "{{\\bf R}}", "Sb": "{{\\bf S}}", "ub": "{{\\bf u}}", "Ub": "{{\\bf U}}", "xb": "{{\\bf x}}", "dt": "{\\Delta t}", "omegadot": "{\\dot\\omega}", "inp": "{{\\rm in}}", "outp": "{{\\rm out}}", "sync": "{{\\rm sync}}", "half": "{\\frac{1}{2}}", "myhalf": "{\\half}", "nph": "{{n+\\myhalf}}", "kpp": "{\\ensuremath{\\kappa_{\\mathrm{P}}}}", "kpr": "{\\ensuremath{\\kappa_{\\mathrm{R}}}}", "kpf": "{\\ensuremath{\\kappa_{\\mathrm{F}}}}", "vb": "{\\boldsymbol{v}}", "vbt": "{\\widetilde{\\vb}}", "rbt": "{\\widetilde{\\rb}}", "ob": "{\\boldsymbol{\\omega}}", "nablab": "{\\boldsymbol{\\nabla}}"}}})</script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>